# SPEC-048: Proposal

## Overview

Extend hash/eq contract testing to all hashable classes in the codebase beyond `ContextItem`. This includes creating a reusable helper function for contract verification and documenting the audit results.

## Audit Results

### Audit Date: 2026-01-28

### Classes with Custom `__hash__` and `__eq__`

| Class | Location | Hash Implementation | Eq Implementation | Already Tested |
|-------|----------|---------------------|-------------------|----------------|
| `ContextItem` | `src/clams/context/models.py` | `(source, content[:100], len(content))` | `(source, content)` | Yes (SPEC-047) |

### Classes with `frozen=True` (Auto-generated hash/eq)

| Class | Location | Fields Used for Hash/Eq | Notes |
|-------|----------|-------------------------|-------|
| `PlatformInfo` | `src/clams/utils/platform.py` | All 14 fields (os_name, os_version, machine, is_macos, is_linux, is_apple_silicon, has_nvidia_gpu, mps_available, cuda_available, has_ripgrep, ripgrep_path, has_docker, docker_path, docker_running, qdrant_available, qdrant_url) | Auto-generated by `@dataclass(frozen=True)` |

### Enum Classes (Inherently Hashable)

Python Enums are inherently hashable and their hash/eq implementation is provided by the Enum base class. They use identity-based hashing and equality, which inherently satisfies the contract. These do NOT require explicit testing.

| Enum | Location |
|------|----------|
| `Domain` | `src/clams/observation/models.py` |
| `Strategy` | `src/clams/observation/models.py` |
| `OutcomeStatus` | `src/clams/observation/models.py` |
| `ConfidenceTier` | `src/clams/observation/models.py` |
| `UnitType` | `src/clams/indexers/base.py` |

### Classes Intentionally Excluded

| Class | Location | Reason |
|-------|----------|--------|
| All Enum classes | Various | Enum's hash/eq is identity-based, handled by Python stdlib, always satisfies contract |
| Standard dataclasses | Various | Not hashable by default (no `frozen=True` or `__hash__`), cannot be used in sets/dicts as keys |

### Non-Hashable Dataclasses (No Testing Needed)

These dataclasses do NOT define `__hash__` and are not frozen, so they are not hashable:
- `FormattedContext`, `ContextAssemblyError`, `InvalidContextTypeError` (`src/clams/context/models.py`)
- `ClusterResult`, `ClusterInfo` (`src/clams/clustering/types.py`)
- `RootCause`, `Lesson`, `HistoryEntry`, `Outcome`, `GHAPEntry` (`src/clams/observation/models.py`)
- `ValidationResult`, `Value`, `ClusterInfo`, `Experience` (`src/clams/values/types.py`)
- `SearchResult`, `CollectionInfo` (`src/clams/storage/base.py`)
- `MemoryResult`, `CodeResult`, `ExperienceResult`, `ValueResult`, `CommitResult` (`src/clams/search/results.py`)
- `SemanticUnit`, `IndexingError`, `IndexingStats` (`src/clams/indexers/base.py`)

## File Changes

| File | Action | Description |
|------|--------|-------------|
| `tests/context/test_data_contracts.py` | Modify | Add reusable helper and audit documentation |
| `tests/utils/test_platform_contracts.py` | Create | Contract tests for `PlatformInfo` |

## Implementation Details

### 1. Reusable Helper Function

Add to `tests/context/test_data_contracts.py`:

```python
from typing import Any, TypeVar

T = TypeVar("T")


def verify_hash_eq_contract(
    cls: type[T],
    *args: Any,
    **kwargs: Any,
) -> None:
    """Verify hash/eq contract for any class.

    Creates two instances with the same arguments and verifies:
    1. They are equal
    2. They have the same hash (contract requirement)
    3. Set membership is consistent
    4. Dict key lookup is consistent

    Args:
        cls: Class to test
        *args: Positional arguments for constructor
        **kwargs: Keyword arguments for constructor

    Raises:
        AssertionError: If contract is violated
    """
    obj1 = cls(*args, **kwargs)
    obj2 = cls(*args, **kwargs)

    # Basic equality check
    assert obj1 == obj2, (
        f"{cls.__name__}: instances with same args must be equal"
    )

    # Contract: equal objects must have equal hashes
    assert hash(obj1) == hash(obj2), (
        f"{cls.__name__} violates hash/eq contract: "
        f"equal objects have different hashes "
        f"(hash1={hash(obj1)}, hash2={hash(obj2)})"
    )

    # Set membership must be consistent
    s: set[T] = {obj1}
    assert obj2 in s, (
        f"{cls.__name__}: equal object not found in set "
        f"(contract violation)"
    )

    # Dict key lookup must be consistent
    d: dict[T, str] = {obj1: "value"}
    assert d.get(obj2) == "value", (
        f"{cls.__name__}: equal object cannot find dict entry "
        f"(contract violation)"
    )
```

### 2. Audit Documentation Header

Add to the top of `tests/context/test_data_contracts.py`:

```python
"""Tests for hash/eq contracts across the codebase.

Python's hash/eq contract requires:
- If a == b, then hash(a) == hash(b)
- If hash(a) != hash(b), then a != b

Violating this contract causes silent bugs in set/dict operations.

## Hashable Classes Audit (2026-01-28)

Classes tested in this file:
- ContextItem (src/clams/context/models.py) - custom __hash__/__eq__

Classes tested in tests/utils/test_platform_contracts.py:
- PlatformInfo (src/clams/utils/platform.py) - frozen dataclass

Classes excluded (Enums use identity-based hash/eq, always correct):
- Domain, Strategy, OutcomeStatus, ConfidenceTier (observation/models.py)
- UnitType (indexers/base.py)

All other dataclasses are NOT hashable (no frozen=True or __hash__).

Reference: BUG-028 - ContextItem hash/eq contract violation
"""
```

### 3. PlatformInfo Contract Tests

Create `tests/utils/test_platform_contracts.py`:

```python
"""Tests for PlatformInfo hash/eq contract.

PlatformInfo uses @dataclass(frozen=True), which auto-generates
__hash__ and __eq__ based on all fields. This is safe but should
be tested to catch regressions if fields are added or the decorator
is changed.

Reference: SPEC-048 - Hash/Eq Contract Tests for Other Hashable Classes
"""

import pytest
from hypothesis import given, settings
from hypothesis import strategies as st

from clams.utils.platform import PlatformInfo


class TestPlatformInfoContract:
    """Verify PlatformInfo maintains hash/eq contract.

    Since PlatformInfo is a frozen dataclass, its hash/eq is
    auto-generated based on all fields. This should always satisfy
    the contract, but we test to catch regressions.
    """

    def test_equal_instances_have_equal_hashes(self) -> None:
        """INVARIANT: if a == b then hash(a) == hash(b)."""
        info1 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )
        info2 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )

        assert info1 == info2, "Identical instances must be equal"
        assert hash(info1) == hash(info2), (
            "Contract violation: equal instances must have equal hashes"
        )

    def test_different_instances_are_not_equal(self) -> None:
        """Instances with different fields must not be equal."""
        base = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )
        different = PlatformInfo(
            os_name="linux",  # Different OS
            os_version="Linux-6.0",
            machine="x86_64",
            is_macos=False,
            is_linux=True,
            is_apple_silicon=False,
            has_nvidia_gpu=True,
            mps_available=False,
            cuda_available=True,
            has_ripgrep=True,
            ripgrep_path="/usr/bin/rg",
            has_docker=True,
            docker_path="/usr/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )

        assert base != different, "Different instances must not be equal"

    def test_single_field_difference(self) -> None:
        """Changing any single field should make instances unequal."""
        base_kwargs = {
            "os_name": "darwin",
            "os_version": "macOS-14.0",
            "machine": "arm64",
            "is_macos": True,
            "is_linux": False,
            "is_apple_silicon": True,
            "has_nvidia_gpu": False,
            "mps_available": True,
            "cuda_available": False,
            "has_ripgrep": True,
            "ripgrep_path": "/usr/local/bin/rg",
            "has_docker": True,
            "docker_path": "/usr/local/bin/docker",
            "docker_running": True,
            "qdrant_available": True,
            "qdrant_url": "http://localhost:6333",
        }

        base = PlatformInfo(**base_kwargs)

        # Test each boolean field flip
        for field in [
            "is_macos", "is_linux", "is_apple_silicon",
            "has_nvidia_gpu", "mps_available", "cuda_available",
            "has_ripgrep", "has_docker", "docker_running",
            "qdrant_available",
        ]:
            modified = dict(base_kwargs)
            modified[field] = not modified[field]
            different = PlatformInfo(**modified)
            assert base != different, f"Changing {field} should make unequal"


class TestPlatformInfoSetBehavior:
    """Test set operations with PlatformInfo."""

    def test_set_membership_consistent(self) -> None:
        """Equal instances have consistent set membership."""
        info1 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )
        info2 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )

        s: set[PlatformInfo] = {info1}
        assert info2 in s, "Equal instance not found in set (contract violation)"

    def test_set_deduplication(self) -> None:
        """Adding equal instances should result in one item."""
        kwargs = {
            "os_name": "darwin",
            "os_version": "macOS-14.0",
            "machine": "arm64",
            "is_macos": True,
            "is_linux": False,
            "is_apple_silicon": True,
            "has_nvidia_gpu": False,
            "mps_available": True,
            "cuda_available": False,
            "has_ripgrep": True,
            "ripgrep_path": "/usr/local/bin/rg",
            "has_docker": True,
            "docker_path": "/usr/local/bin/docker",
            "docker_running": True,
            "qdrant_available": True,
            "qdrant_url": "http://localhost:6333",
        }

        s: set[PlatformInfo] = set()
        for _ in range(3):
            s.add(PlatformInfo(**kwargs))

        assert len(s) == 1, f"Expected 1 item after deduplication, got {len(s)}"


class TestPlatformInfoDictBehavior:
    """Test dict operations with PlatformInfo as key."""

    def test_dict_key_lookup(self) -> None:
        """Equal instances can find dict entries."""
        info1 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )
        info2 = PlatformInfo(
            os_name="darwin",
            os_version="macOS-14.0",
            machine="arm64",
            is_macos=True,
            is_linux=False,
            is_apple_silicon=True,
            has_nvidia_gpu=False,
            mps_available=True,
            cuda_available=False,
            has_ripgrep=True,
            ripgrep_path="/usr/local/bin/rg",
            has_docker=True,
            docker_path="/usr/local/bin/docker",
            docker_running=True,
            qdrant_available=True,
            qdrant_url="http://localhost:6333",
        )

        d: dict[PlatformInfo, str] = {info1: "cached_value"}
        assert d.get(info2) == "cached_value", (
            "Equal instance cannot find dict entry (contract violation)"
        )
```

### 4. Refactor Existing ContextItem Tests

The existing tests in `tests/context/test_data_contracts.py` are comprehensive and well-structured. We will:

1. Add the audit documentation header
2. Add the `verify_hash_eq_contract` helper function
3. Keep all existing tests unchanged (they already cover the requirements)

## Function Signatures

### Helper Function

```python
def verify_hash_eq_contract(
    cls: type[T],
    *args: Any,
    **kwargs: Any,
) -> None:
    """Verify hash/eq contract for any class."""
```

### New Test Module

```
tests/utils/test_platform_contracts.py
  - class TestPlatformInfoContract
    - test_equal_instances_have_equal_hashes()
    - test_different_instances_are_not_equal()
    - test_single_field_difference()
  - class TestPlatformInfoSetBehavior
    - test_set_membership_consistent()
    - test_set_deduplication()
  - class TestPlatformInfoDictBehavior
    - test_dict_key_lookup()
```

## Testing Strategy

1. **Run existing tests**: `pytest tests/context/test_data_contracts.py -v`
2. **Run new tests**: `pytest tests/utils/test_platform_contracts.py -v`
3. **Verify helper function**: Write a simple test case using the helper
4. **Mutation testing**: Temporarily change `PlatformInfo` to non-frozen to verify tests catch it

## Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|------------|------------|
| PlatformInfo fields change | Medium | Tests will fail if fields are added/removed without updating tests |
| Missing hashable classes | Low | Comprehensive grep audit documented; pre-commit hook (SPEC-049) will catch future additions |
| Enum tests unnecessary | Very Low | Documented exclusion rationale; Enum contract is guaranteed by Python |

## Notes

- The audit found only **2 hashable classes** requiring tests: `ContextItem` (already tested) and `PlatformInfo` (new)
- Enums are excluded because Python's Enum implementation guarantees the hash/eq contract
- Non-frozen dataclasses are not hashable and don't need testing
- The helper function `verify_hash_eq_contract` can be used by SPEC-049's pre-commit hook to test new hashable classes
