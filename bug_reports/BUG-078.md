# Bug Report: BUG-078

## Title
No memory/GHAP backup in SQLite database backups

## First Noticed On Commit
eeee713

## Reproduction Steps
1. Store memories via `mcp__calm__store_memory`
2. Create GHAP entries via `mcp__calm__start_ghap`
3. Run `calm backup create`
4. Check the backup â€” memories and GHAP entries stored in Qdrant are not included

## Expected Behavior
`calm backup create` should back up all persistent data, including memories and GHAP entries that live in the vector store (Qdrant), not just the SQLite metadata database.

## Actual Behavior
Only the SQLite database (`~/.calm/metadata.db`) is backed up. Memories and GHAP entries stored in Qdrant collections are not backed up and could be lost if Qdrant data is corrupted or the Docker volume is removed.

## Reproduction Confirmed

Verified by reading the code. The `create_backup()` function in `src/calm/orchestration/backups.py` (line 31-66) does exactly one thing:

```python
shutil.copy2(db_path, backup_path)
```

This copies only `~/.calm/metadata.db`. No code anywhere in the backup module touches Qdrant.

## Root Cause

The backup system was designed to back up only the SQLite metadata database and was never extended to include Qdrant vector store data. The `create_backup()`, `auto_backup()`, `restore_backup()`, and `list_backups()` functions in `src/calm/orchestration/backups.py` exclusively operate on the single SQLite `.db` file.

CALM stores data across **two** persistence layers:

1. **SQLite** (`~/.calm/metadata.db`) -- tasks, workers, sessions, counters, reviews, test runs, indexed file metadata, session journals
2. **Qdrant** (Docker container at `http://localhost:6333`) -- 8 collections containing vector embeddings + payloads

The following Qdrant collections contain data that is NOT backed up:

| Collection | Data | Criticality |
|------------|------|-------------|
| `memories` | User memories (content, category, importance, tags, timestamps) | **HIGH** -- irreplaceable user knowledge |
| `ghap_full` | Full GHAP experience embeddings (goal, hypothesis, action, prediction, outcome) | **HIGH** -- accumulated learning |
| `ghap_strategy` | Strategy-axis GHAP embeddings | **HIGH** -- accumulated learning |
| `ghap_surprise` | Surprise-axis GHAP embeddings | **MEDIUM** -- only falsified entries |
| `ghap_root_cause` | Root-cause-axis GHAP embeddings | **MEDIUM** -- only falsified entries |
| `values` | Validated value statements (text, cluster_id, axis) | **HIGH** -- distilled insights |
| `commits` | Git commit embeddings | **LOW** -- re-indexable from git history |
| `code_units` | Code unit embeddings (functions, classes) | **LOW** -- re-indexable from source |

The high-criticality collections (`memories`, `ghap_*`, `values`) contain irreplaceable data that cannot be regenerated. The low-criticality collections (`commits`, `code_units`) can be rebuilt by re-indexing.

### Why Other Hypotheses Were Eliminated

1. **Hypothesis: Qdrant data is backed up somewhere else** -- Searched the entire codebase for any Qdrant snapshot or export logic. None exists. The only backup-related code is in `src/calm/orchestration/backups.py` and `src/calm/cli/backup.py`, both of which operate exclusively on SQLite.

2. **Hypothesis: Data is dual-written to both SQLite and Qdrant** -- Checked all tool implementations. Memories (`src/calm/tools/memory.py`) are stored ONLY in Qdrant via `vector_store.upsert()`. GHAP entries are written to local JSON files by `ObservationCollector` (in `~/.calm/journal/`) and then persisted to Qdrant by `ObservationPersister`. The local JSON files are only for the active GHAP entry (`current_ghap.json`); resolved entries are archived to `journal/archive/` but are not reliably preserved long-term. Values are stored only in Qdrant.

3. **Hypothesis: Qdrant's Docker volume provides sufficient persistence** -- Docker volumes persist across container restarts, but they can be lost via `docker volume rm`, `docker system prune`, container recreation, or disk corruption. Without an explicit backup mechanism, this is a single point of failure.

### Evidence

- `src/calm/orchestration/backups.py` line 59: `shutil.copy2(db_path, backup_path)` -- the only persistence operation in backup creation
- `src/calm/tools/memory.py` line 142-146: memories are stored only in Qdrant via `vector_store.upsert(collection="memories", ...)`
- `src/calm/ghap/persister.py` line 92-98: resolved GHAP entries are stored in Qdrant via `vector_store.upsert(collection=collection_name, ...)`
- `src/calm/values/store.py` line 218: values are stored in Qdrant via `vector_store.upsert(collection=VALUES_COLLECTION, ...)`
- `src/calm/search/collections.py` lines 13-19: defines all 8 collection names used in Qdrant

## Fix Plan

Use Qdrant's native snapshot API (available in qdrant_client v1.12.1) to create full-storage snapshots alongside SQLite backups. Gracefully degrade when Qdrant is unreachable.

### Recommended Approach: Qdrant Native Snapshots

The `qdrant_client` library (v1.12.1) provides built-in snapshot methods on `AsyncQdrantClient`:

- `create_full_snapshot()` -- Creates a snapshot of all collections at once
- `list_full_snapshots()` -- Lists available full snapshots
- `recover_snapshot(collection_name, location)` -- Restores a collection from a snapshot file
- `delete_full_snapshot(snapshot_name)` -- Deletes a snapshot

Snapshots are stored server-side in Qdrant's snapshot directory and can also be downloaded.

#### Approach: Per-Collection Snapshots via Qdrant API

Use `create_snapshot(collection_name)` for each of the 8 collections, or (simpler) use `create_full_snapshot()` to snapshot everything at once. Download the snapshot files to `~/.calm/backups/` alongside the SQLite backup.

### Specific Code Changes

#### 1. `src/calm/orchestration/backups.py`

- Add an async function `create_qdrant_snapshot(qdrant_url: str, backup_name: str) -> Path | None` that:
  1. Creates an `AsyncQdrantClient` connected to the configured Qdrant URL
  2. Calls `create_full_snapshot(wait=True)` to create a server-side snapshot
  3. Downloads the snapshot file to `~/.calm/backups/{backup_name}.qdrant.snapshot`
  4. Returns the path to the downloaded snapshot, or `None` if Qdrant is unreachable (graceful degradation)

- Add an async function `restore_qdrant_snapshot(qdrant_url: str, backup_name: str) -> bool` that:
  1. Checks if a Qdrant snapshot file exists for this backup
  2. Uses Qdrant's snapshot recovery API to restore from the file
  3. Returns True if restored, False if no snapshot file found

- Modify `create_backup()` to become async and call `create_qdrant_snapshot()` after copying SQLite
- Modify `restore_backup()` to become async and call `restore_qdrant_snapshot()` after restoring SQLite
- Modify `auto_backup()` to become async and include Qdrant snapshots in rotation

- Update the `Backup` dataclass to track whether a Qdrant snapshot is included:
  ```python
  @dataclass
  class Backup:
      name: str
      path: Path
      created_at: datetime
      size_bytes: int
      has_qdrant_snapshot: bool = False
      qdrant_snapshot_path: Path | None = None
  ```

- **Graceful degradation**: If Qdrant is unreachable (e.g., Docker not running), backup creation should still succeed for SQLite and log a warning about the missing Qdrant snapshot. This matches the existing pattern in `server/app.py` where `git_analyzer` gracefully falls back if not in a git repo.

#### 2. `src/calm/cli/backup.py`

- Update CLI commands to use `asyncio.run()` for the now-async backup functions
- Update `create` command output to show whether Qdrant snapshot was included
- Update `list` command to show Qdrant snapshot status for each backup
- Update `restore` command to restore Qdrant snapshot if present

#### 3. `src/calm/storage/qdrant.py`

- Add a `create_snapshot()` method to `QdrantVectorStore` that wraps the client's snapshot API
- Add a `download_snapshot()` method that downloads the snapshot to a local path
- Add a `list_snapshots()` method to enumerate available snapshots

Alternatively, the backup module can create its own `AsyncQdrantClient` directly (simpler, avoids coupling to the VectorStore abstraction which is focused on collection CRUD).

#### 4. Tests

- `tests/calm/orchestration/test_backups.py`:
  - Add tests for `create_qdrant_snapshot()` with a mock Qdrant client
  - Add tests for graceful degradation when Qdrant is unreachable
  - Add tests for `restore_qdrant_snapshot()`
  - Add tests for backup listing showing Qdrant snapshot status
  - Add tests for auto-backup rotation of Qdrant snapshots

### Regression Test Requirements

1. **Test: backup includes Qdrant snapshot** -- Create a backup with a mock Qdrant client, verify both SQLite copy and Qdrant snapshot file exist
2. **Test: backup works when Qdrant is down** -- Create a backup with Qdrant unreachable, verify SQLite backup still succeeds and a warning is logged
3. **Test: restore includes Qdrant restore** -- Restore a backup that has a Qdrant snapshot, verify the restore API is called
4. **Test: auto-backup rotates Qdrant snapshots** -- Create multiple auto-backups, verify old Qdrant snapshot files are cleaned up alongside old SQLite backups
5. **Test: list shows Qdrant status** -- List backups and verify the `has_qdrant_snapshot` field is correctly populated

### Data Criticality Tiers for Backup

Not all collections are equally important. The fix should back up ALL collections (via `create_full_snapshot()`), but the documentation should note:

- **Must backup (irreplaceable)**: `memories`, `ghap_full`, `ghap_strategy`, `ghap_surprise`, `ghap_root_cause`, `values`
- **Nice to backup (re-generable)**: `commits`, `code_units`

Using `create_full_snapshot()` is simpler than per-collection snapshots and captures everything atomically.

### Verification

After implementation, verify by:
1. Running `calm backup create test_with_qdrant`
2. Checking that `~/.calm/backups/test_with_qdrant.db` AND `~/.calm/backups/test_with_qdrant.qdrant.snapshot` both exist
3. Running `calm backup list` and confirming Qdrant snapshot status is shown
4. Stopping Qdrant, running `calm backup create test_no_qdrant`, and confirming SQLite backup succeeds with a warning about missing Qdrant snapshot
