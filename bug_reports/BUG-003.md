# BUG-003: index_codebase should re-index if collection exists, not throw error

## Reported

- **First noticed on commit**: d16356d
- **Reported by**: orchestrator
- **Reported at**: 2025-12-06T17:53:00
- **Severity**: medium

## Reproduction Steps

1. Start the MCP server with Qdrant backend
2. Call `index_codebase` with a directory and project name - this succeeds
3. Call `index_codebase` again with the same or different directory/project

**Expected**: The codebase should be re-indexed (updating existing entries, adding new ones)
**Actual**: Returns error: `Failed to index codebase: Unexpected Response: 409 (Conflict) - Collection 'code_units' already exists!`

---

## Investigation (filled by Bug Investigator)

### Reproduction Confirmed

- [x] Steps reproduced bug

**Observations during reproduction**:
- Bug occurs when using **real Qdrant server** (http://localhost:6333)
- Bug does **NOT** occur with `:memory:` mode
- Error: `UnexpectedResponse: Unexpected Response: 409 (Conflict) - Collection 'test_bug_003' already exists!`

### Initial Hypothesis

The `_ensure_collection()` method in `src/learning_memory_server/indexers/indexer.py` (lines 39-63) catches `ValueError` to handle duplicate collections, but with a real Qdrant server, duplicate collection creation raises `UnexpectedResponse` instead.

### Differential Diagnosis

| # | Hypothesis | If True, Would See | If False, Would See | Evidence | Status |
|---|------------|-------------------|---------------------|----------|--------|
| 1 | In-memory Qdrant raises `ValueError`, real server raises different exception | In-memory works, server fails with UnexpectedResponse | Both modes fail with same exception | Tested both: `:memory:` raises `ValueError`, server raises `UnexpectedResponse` | **Confirmed** |
| 2 | Exception hierarchy: UnexpectedResponse is NOT a ValueError | `issubclass(UnexpectedResponse, ValueError)` returns False | Returns True | Checked: `UnexpectedResponse.__bases__ = (ApiException,)`, not ValueError | **Confirmed** |
| 3 | The catch block in indexer.py only catches ValueError | Second call on server fails, in-memory succeeds | Both fail or both succeed | In-memory succeeds (caught), server fails (not caught) | **Confirmed** |

### Evidentiary Scaffold

**Test script to discriminate exception types**:
```python
# Purpose: Verify exception types differ between :memory: and server modes

from qdrant_client import AsyncQdrantClient
from qdrant_client.http import models as qmodels
import asyncio

async def test():
    # Test 1: In-memory mode
    client_mem = AsyncQdrantClient(location=':memory:')
    await client_mem.create_collection(
        collection_name='test',
        vectors_config=qmodels.VectorParams(size=384, distance=qmodels.Distance.COSINE)
    )
    try:
        await client_mem.create_collection(
            collection_name='test',
            vectors_config=qmodels.VectorParams(size=384, distance=qmodels.Distance.COSINE)
        )
    except Exception as e:
        print(f'In-memory mode: {type(e).__name__}: {e}')

    # Test 2: Server mode
    client_server = AsyncQdrantClient(url='http://localhost:6333')
    await client_server.create_collection(
        collection_name='test_bug',
        vectors_config=qmodels.VectorParams(size=384, distance=qmodels.Distance.COSINE)
    )
    try:
        await client_server.create_collection(
            collection_name='test_bug',
            vectors_config=qmodels.VectorParams(size=384, distance=qmodels.Distance.COSINE)
        )
    except Exception as e:
        print(f'Server mode: {type(e).__name__}: {e}')

asyncio.run(test())
```

**Captured output**:
```
In-memory mode: ValueError: Collection test already exists
Server mode: UnexpectedResponse: Unexpected Response: 409 (Conflict)
Raw response content:
b'{"status":{"error":"Wrong input: Collection `test_bug` already exists!"},"time":0.000043916}'
```

**Exception hierarchy check**:
```python
from qdrant_client.http.exceptions import UnexpectedResponse
print(f'UnexpectedResponse base classes: {UnexpectedResponse.__bases__}')
# Output: (<class 'qdrant_client.http.exceptions.ApiException'>,)
print(f'Is it a ValueError? {issubclass(UnexpectedResponse, ValueError)}')
# Output: False
```

### Root Cause (Proven)

**The bug is caused by**: The `_ensure_collection()` method in `src/learning_memory_server/indexers/indexer.py` (line 58) only catches `ValueError` when attempting to create a collection. However, the Qdrant client library raises different exceptions depending on the backend:
- In-memory mode (`:memory:`): raises `ValueError`
- Server mode (HTTP): raises `UnexpectedResponse` (a subclass of `ApiException`, not `ValueError`)

Since the exception handler doesn't catch `UnexpectedResponse`, the exception propagates up through `code.py:97` and gets wrapped as `MCPError: Failed to index codebase: Unexpected Response: 409 (Conflict)...`

**Evidence**:
1. Direct testing shows `:memory:` raises `ValueError`, server raises `UnexpectedResponse`
2. `UnexpectedResponse` inherits from `ApiException`, not `ValueError`
3. The catch block at `indexer.py:58` only catches `ValueError`
4. In-memory mode works (caught), server mode fails (not caught)

**Why alternatives were eliminated**:
All three hypotheses were confirmed (not eliminated) - they work together to explain the bug:
1. Different exception types between backends → Confirmed by testing both modes
2. Exception hierarchy incompatibility → Confirmed by checking `__bases__`
3. Incomplete exception handling → Confirmed by code inspection and behavior testing

---

## Fix Plan

### Code Changes

1. **File**: `src/learning_memory_server/indexers/indexer.py`
   **Function**: `_ensure_collection` (lines 39-63)
   **Change**: Expand the exception handler to catch both `ValueError` (for in-memory mode) and `Exception` (to handle all backend-specific exceptions including `UnexpectedResponse` from server mode). Check if the exception message indicates the collection already exists.
   **Rationale**:
   - Catches both in-memory (`ValueError`) and server (`UnexpectedResponse`) duplicate collection errors
   - Broad `Exception` catch is safe here because we verify the message contains "already exists"
   - If it's a different error, re-raise it
   - This makes the code resilient to future Qdrant client changes

2. **File**: `src/learning_memory_server/indexers/indexer.py`
   **Import section**: Add import for proper exception handling (if needed for message checking)
   **Change**: No additional imports needed - we'll use string matching on the exception message
   **Rationale**: Simple, backend-agnostic solution

### Regression Test

**Test file**: `tests/indexers/test_bug_003_regression.py` (new file)

**Test should**:
1. Test with both in-memory and server backends (if server available)
2. Call `index_directory()` twice on the same directory
3. Verify both calls succeed (no exception raised)
4. Verify the second call updates/re-indexes as expected

**Test outline**:
```python
import pytest
from pathlib import Path
from learning_memory_server.indexers.indexer import CodeIndexer
from learning_memory_server.storage.qdrant import QdrantVectorStore
# ... other imports

@pytest.mark.asyncio
async def test_bug_003_double_index_inmemory(
    code_indexer,  # fixture with :memory: backend
    tmp_path
):
    """Regression test: index_codebase should work on second call (in-memory mode)."""
    # Create a test file
    test_file = tmp_path / "test.py"
    test_file.write_text("def hello(): pass")

    # First index
    stats1 = await code_indexer.index_directory(
        path=str(tmp_path),
        project="test",
        recursive=False
    )
    assert stats1.files_indexed >= 1

    # Second index - should not raise exception
    stats2 = await code_indexer.index_directory(
        path=str(tmp_path),
        project="test",
        recursive=False
    )
    # Should succeed (may skip if unchanged)
    assert stats2.files_skipped >= 0 or stats2.files_indexed >= 0

@pytest.mark.integration
@pytest.mark.asyncio
async def test_bug_003_double_index_server(
    qdrant_server_available,  # fixture that checks if server running
    tmp_path
):
    """Regression test: index_codebase should work on second call (server mode).

    This test specifically reproduces the original bug with a real Qdrant server.
    """
    if not qdrant_server_available:
        pytest.skip("Qdrant server not available")

    # Setup indexer with server backend
    # ... create indexer with url='http://localhost:6333'

    # Create test file
    test_file = tmp_path / "test.py"
    test_file.write_text("def world(): pass")

    # First index
    stats1 = await indexer.index_directory(
        path=str(tmp_path),
        project="bug003test",
        recursive=False
    )
    assert stats1.files_indexed >= 1

    # Second index - this raised UnexpectedResponse before the fix
    stats2 = await indexer.index_directory(
        path=str(tmp_path),
        project="bug003test",
        recursive=False
    )
    # Should succeed
    assert stats2.files_skipped >= 0 or stats2.files_indexed >= 0
```

### Verification

After implementing the fix:
```bash
# Run specific regression test
pytest tests/indexers/test_bug_003_regression.py -vvsx

# Run all indexer tests
pytest tests/indexers/ -vvsx

# Run full test suite
pytest -vvsx
```

---

## Implementation (filled by Implementer)

- **Implemented by**: [worker ID]
- **Commit**: [SHA]
- **Regression test file**: [path]

### Changes Made

[Brief summary of actual changes vs plan]

---

## Review (filled by Reviewers)

| Review # | Reviewer | Result | Date |
|----------|----------|--------|------|
| 1 | [worker ID] | [approved/changes_requested] | [date] |
| 2 | [worker ID] | [approved/changes_requested] | [date] |

---

## Resolution

- **Fixed in commit**: [SHA on main]
- **Verified by**: [worker ID]
- **Closed at**: [timestamp]
