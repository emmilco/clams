# BUG-028: Hash/Eq contract violation in ContextItem

## Reported

- **First noticed on commit**: e2fab06
- **Reported by**: orchestrator (bug hunt agent)
- **Reported at**: 2025-12-08
- **Severity**: medium

## Reproduction Steps

1. Create two ContextItems with same source and same first 100 characters but different full content
2. Add both to a set
3. Check set contents

**Expected**: Both items in set (they are not equal)
**Actual**: Behavior depends on hash collision handling, may lose items or have inconsistent lookups

## Code Location

**File**: `src/clams/context/models.py`
**Lines**: 16-24

```python
def __hash__(self) -> int:
    """Make hashable for set operations (deduplication)."""
    return hash((self.source, self.content[:100]))  # First 100 chars for perf

def __eq__(self, other: object) -> bool:
    """Compare for equality (deduplication)."""
    if not isinstance(other, ContextItem):
        return False
    return self.source == other.source and self.content == other.content
```

## Analysis

Python's hash/eq contract requires:
- If `a == b`, then `hash(a) == hash(b)` (satisfied)
- Objects with same hash MAY be equal (collision is allowed)
- BUT: hash should ideally correlate with equality

**The problem**: Two items with identical 100-character prefixes but different full content:
- Have the SAME hash (based on first 100 chars)
- Are NOT equal (based on full content)

This violates the *spirit* of the contract. While Python allows hash collisions, the docstring says this is "for deduplication" - but items with same prefix won't deduplicate correctly:

```python
item1 = ContextItem(source="file.py", content="A"*100 + "X")
item2 = ContextItem(source="file.py", content="A"*100 + "Y")

hash(item1) == hash(item2)  # True - same bucket
item1 == item2              # False - not equal

s = {item1}
item2 in s                  # False (correctly not found)
s.add(item2)               # Both items now in set
len(s)                     # 2 (not deduplicated!)
```

**Impact**:
- Deduplication doesn't work for items with similar prefixes
- Dict lookups may have degraded performance (hash collisions)
- Set operations behave unexpectedly

---

## Investigation (filled by Bug Investigator)

### Reproduction Confirmed

- [ ] Steps reproduced bug

**Observations during reproduction**:
[What did you observe when reproducing?]

### Initial Hypothesis

[What do you believe is causing this bug? Be specific: file, function, line.]

### Differential Diagnosis

| # | Hypothesis | If True, Would See | If False, Would See | Evidence | Status |
|---|------------|-------------------|---------------------|----------|--------|
| 1 | [Hypothesis A] | [Observable X] | [Observable Y] | [What you saw] | [Eliminated/Confirmed/Pending] |

### Evidentiary Scaffold

**Logging/assertions added**:
```python
# Location: file.py:123
# Purpose: Distinguish between hypothesis 1 and 2
logger.debug(f"State at critical point: {state}")
```

**Test command**:
```bash
[Command to run with scaffold in place]
```

**Captured output**:
```
[Actual output from scaffold run]
```

### Root Cause (Proven)

**The bug is caused by**: [Specific root cause]

**Evidence**: [What proves this is the cause]

**Why alternatives were eliminated**:
- Hypothesis 1 eliminated because: [reason with evidence]

---

## Fix Plan

### Code Changes

Option A (consistency): Hash full content
1. **File**: `src/clams/context/models.py`
   **Function**: `__hash__`
   **Change**: Hash full content, not just first 100 chars
   **Rationale**: Hash matches eq behavior
   **Tradeoff**: Slightly slower hashing for large content

Option B (performance): Eq uses first 100 chars too
1. **File**: `src/clams/context/models.py`
   **Function**: `__eq__`
   **Change**: Compare only first 100 chars
   **Rationale**: Faster equality check
   **Tradeoff**: May incorrectly deduplicate distinct items

Option C (hybrid): Hash includes content length
1. **File**: `src/clams/context/models.py`
   **Function**: `__hash__`
   **Change**: `hash((self.source, self.content[:100], len(self.content)))`
   **Rationale**: Reduces collisions while keeping perf benefits

### Regression Test

**Test file**: `tests/test_bug_028_regression.py`

**Test should**:
1. Create two items with same 100-char prefix but different full content
2. Verify they are treated correctly in sets/dicts
3. Verify deduplication works as intended

**Test outline**:
```python
def test_bug_028_hash_eq_contract():
    prefix = "A" * 100
    item1 = ContextItem(source="file.py", content=prefix + "X")
    item2 = ContextItem(source="file.py", content=prefix + "Y")

    # These should NOT be equal
    assert item1 != item2

    # In a set, both should be present (or neither if dedup intended)
    s = {item1, item2}
    # Decide expected behavior based on fix choice
```

### Verification

After implementing the fix:
```bash
# Run specific test
pytest tests/test_bug_028_regression.py -xvs

# Run full test suite
pytest -xvs
```

---

## Implementation (filled by Implementer)

- **Implemented by**: [worker ID]
- **Commit**: [SHA]
- **Regression test file**: [path]

### Changes Made

[Brief summary of actual changes vs plan]

---

## Review (filled by Reviewers)

| Review # | Reviewer | Result | Date |
|----------|----------|--------|------|
| 1 | [worker ID] | [approved/changes_requested] | [date] |
| 2 | [worker ID] | [approved/changes_requested] | [date] |

---

## Resolution

- **Fixed in commit**: [SHA on main]
- **Verified by**: [worker ID]
- **Closed at**: [timestamp]
