# Bug Report: BUG-074

## Title
calm task list --include-done crashes with JSONDecodeError

## First Noticed On Commit
eeee713

## Reproduction Steps
1. Run `calm task list --include-done`
2. Observe crash with JSONDecodeError

## Expected Behavior
Should list all tasks including those in DONE phase.

## Actual Behavior
Crashes with:
```
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
```

Stack trace points to `src/calm/orchestration/tasks.py:62` in `_row_to_task()`:
```python
blocked_by: list[str] = json.loads(blocked_by_str) if blocked_by_str else []
```

A task in the database has a `blocked_by` column containing an empty string `""` instead of `null` or `"[]"`. The truthiness check `if blocked_by_str` passes for `""` (actually no â€” empty string is falsy in Python). The issue may be a non-empty but invalid JSON string like a bare space or other non-JSON value.

## Reproduction Confirmation

Confirmed. Running `calm task list --include-done` crashes with:

```
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
```

at `src/calm/orchestration/tasks.py:62` in `_row_to_task()`.

The crash only occurs with `--include-done` because the affected tasks (SPEC-058-02 and SPEC-058-03) are both in DONE phase. Without `--include-done`, DONE tasks are filtered out by the SQL query (`AND phase != 'DONE'`), so the malformed data is never read.

## Differential Diagnosis

### Hypothesis A: Writer bug -- data was written bypassing `update_task()`
If `blocked_by` were written via a direct SQL statement (e.g., `sqlite3` CLI or an older code path), a bare string like `SPEC-058-01` could end up in the column without JSON serialization.

**Discriminating evidence**: The `json.dumps()` function cannot produce the bare string `SPEC-058-01`:
- `json.dumps(["SPEC-058-01"])` produces `'["SPEC-058-01"]'` (JSON array with quotes and brackets)
- `json.dumps("SPEC-058-01")` produces `'"SPEC-058-01"'` (JSON string with quotes)
- Neither matches the raw `SPEC-058-01` found in the database (no quotes, no brackets)

**Conclusion**: The data was written to the database by some path that did NOT use `json.dumps()`, confirming it bypassed the `update_task()` function. This was likely a manual `sqlite3` UPDATE or an older version of the code.

### Hypothesis B: Reader bug -- `_row_to_task()` lacks defensive parsing
The `_row_to_task()` function at line 62 assumes that any non-falsy `blocked_by` value is valid JSON:
```python
blocked_by: list[str] = json.loads(blocked_by_str) if blocked_by_str else []
```
It does not catch `JSONDecodeError`.

**Discriminating evidence**: The `skill_loader.py` (lines 70-76) already handles this defensively with a `try/except json.JSONDecodeError` block, proving the team has encountered (or anticipated) this exact failure mode before. The `_row_to_task()` function lacks the same protection.

### Hypothesis C: Empty string edge case
The original bug report speculated an empty string `""` might be the cause.

**Eliminated**: Empty string is falsy in Python (`bool("") == False`), so the `if blocked_by_str` guard would correctly produce `[]`. The actual values in the database are non-empty strings (`SPEC-058-01`), which are truthy and pass through to `json.loads()`.

## Root Cause

**Dual root cause** -- both a data integrity issue and a missing defensive guard:

1. **Data corruption (writer side)**: Tasks SPEC-058-02 and SPEC-058-03 have `blocked_by` set to the bare string `SPEC-058-01` instead of the JSON array `["SPEC-058-01"]`. This data was written to the database by a path that bypassed `json.dumps()` serialization (likely a direct SQL command or an older code version).

2. **Missing error handling (reader side)**: The `_row_to_task()` function in `src/calm/orchestration/tasks.py:62` does not handle malformed `blocked_by` values. It assumes all non-falsy values are valid JSON arrays. The `skill_loader.py` already has defensive `try/except` handling for this exact scenario, but `_row_to_task()` does not.

**Evidence**:
- Database query: `SELECT id, blocked_by FROM tasks WHERE id IN ('SPEC-058-02', 'SPEC-058-03')` returns `SPEC-058-01` (bare string, not JSON)
- `hex(blocked_by)` returns `535045432D3035382D3031` which is ASCII for `SPEC-058-01` (no JSON quotes or brackets)
- `json.loads("SPEC-058-01")` raises `JSONDecodeError: Expecting value: line 1 column 1 (char 0)` -- the exact error observed
- `bool("SPEC-058-01")` is `True`, so the truthiness guard on line 62 does not protect against this

### Why other hypotheses were eliminated

- **Empty string**: Eliminated because `bool("") == False` and the actual database values are non-empty
- **Whitespace-only string**: Eliminated because hex dump shows the values are exactly `SPEC-058-01` with no whitespace
- **Encoding issue**: Eliminated because the hex dump matches plain ASCII, no BOM or encoding artifacts

## Fix Plan

The fix requires defensive parsing in the reader and a one-time data repair, plus a regression test.

### Fix 1: Defensive parsing in `_row_to_task()` (PRIMARY)

**File**: `src/calm/orchestration/tasks.py`
**Function**: `_row_to_task()` (lines 59-77)
**Change**: Wrap `json.loads()` in a `try/except JSONDecodeError` block, matching the pattern already used in `skill_loader.py`. When the value is not valid JSON, attempt to interpret it as a comma-separated string of task IDs (for backwards compatibility with the corrupted data), or fall back to an empty list.

Replace lines 61-62:
```python
blocked_by_str = row["blocked_by"]
blocked_by: list[str] = json.loads(blocked_by_str) if blocked_by_str else []
```

With:
```python
blocked_by_str = row["blocked_by"]
blocked_by: list[str] = []
if blocked_by_str:
    try:
        blocked_by = json.loads(blocked_by_str)
    except json.JSONDecodeError:
        # Handle malformed data: bare task ID strings stored without JSON serialization
        blocked_by = [s.strip() for s in blocked_by_str.split(",") if s.strip()]
```

### Fix 2: Repair existing corrupted data

**Action**: Run a SQL UPDATE to fix the two corrupted rows:
```sql
UPDATE tasks SET blocked_by = '["SPEC-058-01"]' WHERE id IN ('SPEC-058-02', 'SPEC-058-03');
```

This is a one-time data repair. The defensive parsing (Fix 1) protects against future occurrences regardless.

### Regression Test Requirements

**File**: `tests/calm/orchestration/test_tasks.py`

Add a test in the `TestListTasks` class (or create a new `TestRowToTask` class) that:

1. **Inserts a task with a bare string `blocked_by` value** directly via SQL (bypassing `update_task()`)
2. **Calls `list_tasks(include_done=True)`** (or `get_task()`)
3. **Asserts no crash occurs** and `blocked_by` is correctly parsed as `["SPEC-058-01"]`
4. **Also tests**: empty string, `NULL`, valid JSON array, and a comma-separated multi-value string like `"SPEC-001,SPEC-002"`

### Verification

After applying the fix:
1. `calm task list --include-done` should succeed without crashing
2. Tasks SPEC-058-02 and SPEC-058-03 should show `blocked_by: SPEC-058-01` correctly
3. All existing tests should continue to pass
4. The new regression test should pass
