# BUG-041: Searcher class conflict - abstract vs concrete incompatible interfaces

## Reported

- **First noticed on commit**: 8b5a8b7 (HEAD of main)
- **Reported by**: Codebase auditor
- **Reported at**: 2025-12-11
- **Severity**: High

## Reproduction Steps

1. Check `src/clams/context/searcher_types.py` - abstract `Searcher` class at line 92
2. Check `src/clams/search/searcher.py` - concrete `Searcher` class at line 70
3. Observe that the concrete class does NOT inherit from the abstract one
4. Compare method signatures between the two classes

**Expected**: The concrete `Searcher` should implement the abstract `Searcher` interface
**Actual**: The concrete `Searcher` is a separate class with different method signatures

---

## Investigation (filled by Bug Investigator)

### Reproduction Confirmed

- [x] Steps reproduced bug

**Observations during reproduction**:

1. **Abstract Searcher** (`context/searcher_types.py:92`):
   - `search_memories(self, query: str, limit: int = 20) -> list[MemoryResult]`
   - `search_code(self, query: str, limit: int = 20) -> list[CodeResult]`
   - `search_experiences(self, query: str, axis: str = "full", domain: str | None = None, strategy: str | None = None, outcome: str | None = None, limit: int = 20) -> list[ExperienceResult]`
   - `search_values(self, query: str, limit: int = 5) -> list[ValueResult]`
   - `search_commits(self, query: str, limit: int = 20) -> list[CommitResult]`

2. **Concrete Searcher** (`search/searcher.py:70`):
   - `search_memories(self, query: str, category: str | None = None, limit: int = 10, search_mode: str = "semantic") -> list[MemoryResult]`
   - `search_code(self, query: str, project: str | None = None, language: str | None = None, unit_type: str | None = None, limit: int = 10, search_mode: str = "semantic") -> list[CodeResult]`
   - `search_experiences(self, query: str, axis: str = "full", domain: str | None = None, strategy: str | None = None, outcome: str | None = None, limit: int = 10, search_mode: str = "semantic") -> list[ExperienceResult]`
   - `search_values(self, query: str, axis: str | None = None, limit: int = 5, search_mode: str = "semantic") -> list[ValueResult]`
   - `search_commits(self, query: str, author: str | None = None, since: datetime | None = None, limit: int = 10, search_mode: str = "semantic") -> list[CommitResult]`

3. **Usage in `ContextAssembler`** (`context/assembler.py:18,30`):
   - Imports abstract `Searcher` from `searcher_types`
   - Uses it as type hint: `def __init__(self, searcher: Searcher):`
   - Calls methods with ONLY the abstract signature: `search_memories(query, limit=limit)`, `search_code(query, limit=limit)`, etc.

4. **Test coverage**:
   - `tests/context/test_assembler.py` creates `MockSearcher(Searcher)` that inherits from abstract and uses abstract signatures
   - `tests/integration/test_e2e.py:670` passes concrete `Searcher` to `ContextAssembler` - this works because Python uses duck typing

### Initial Hypothesis

The two `Searcher` classes were designed separately and the concrete implementation was meant to implement the abstract interface but this relationship was never established.

### Differential Diagnosis

| # | Hypothesis | If True, Would See | If False, Would See | Evidence | Status |
|---|------------|-------------------|---------------------|----------|--------|
| 1 | Design oversight - ABC defined but concrete never connected | Two separate classes, concrete has extra params | N/A | Both classes exist independently, concrete has additional params (category, search_mode, etc.) not in ABC | **Confirmed** |
| 2 | ABC is dead code (not used anywhere) | No imports of abstract Searcher | Imports exist | `ContextAssembler` imports and uses abstract `Searcher` for type hints | **Eliminated** |
| 3 | Intentional design - ABC for testing only | Test files inherit from ABC, production code doesn't | Production uses inheritance | `MockSearcher(Searcher)` in tests inherits from ABC, production `Searcher` does not | **Partial** - ABC is used for testing but should also be used in production |
| 4 | Different result types causing conflict | Result classes defined in different places | Same result classes | Concrete imports `MemoryResult` etc from `search/results.py`, ABC defines its own in `context/searcher_types.py` | **Confirmed** - duplicate result types! |

### Evidentiary Scaffold

**Evidence gathering**:

1. Checked imports:
   - `ContextAssembler` imports `Searcher` from `context/searcher_types` (line 18)
   - Concrete `Searcher` in `search/searcher.py` imports results from `search/results.py`
   - There are TWO sets of result classes: `search/results.py` and `context/searcher_types.py`

2. Checked git history:
   - Both files were created in commit `662f9ac` (SPEC-007 rename)
   - No inheritance relationship was ever established

3. Checked integration test:
   - `tests/integration/test_e2e.py:670`: `assembler = ContextAssembler(searcher)` where `searcher` is the concrete one
   - This works due to duck typing but violates type safety

**Test command**:
```bash
cd /Users/elliotmilco/Documents/GitHub/clams && mypy --strict src/clams/context/assembler.py
```

**Result**: mypy would pass because:
- `ContextAssembler` only calls methods with the abstract signature
- The concrete `Searcher` has compatible signatures (extra params have defaults)
- But this relies on duck typing, not proper inheritance

### Root Cause (Proven)

**The bug is caused by**: Design fragmentation - there are two parallel `Searcher` class hierarchies:
1. Abstract `Searcher` in `context/searcher_types.py` with result dataclasses
2. Concrete `Searcher` in `search/searcher.py` with its own result dataclasses in `search/results.py`

The concrete `Searcher` was designed with additional filtering capabilities (category, search_mode, project, language, author, since) that are not in the abstract interface. The abstract interface was designed for `ContextAssembler`'s minimal needs.

**Evidence**:
1. Method signatures differ - concrete has extra parameters
2. Result classes are duplicated between `search/results.py` and `context/searcher_types.py`
3. No inheritance relationship exists
4. Tests use MockSearcher that inherits from ABC, but production code doesn't

**Why alternatives were eliminated**:
- ABC is NOT dead code - it's imported and used by `ContextAssembler`
- This is NOT intentional for testing only - both test and production code use `Searcher` but differently

---

## Fix Plan

### Problem Analysis

The current state has several issues:
1. **Type safety violation**: `ContextAssembler` declares it takes `Searcher` (ABC) but receives concrete `Searcher` (unrelated class)
2. **Duplicate result types**: `MemoryResult`, `CodeResult`, etc. defined in TWO places
3. **Interface mismatch**: Concrete has richer interface than abstract

### Recommended Fix

**Option A (Recommended): Concrete inherits from ABC**
- Make concrete `Searcher` inherit from abstract `Searcher`
- Keep the richer interface in concrete (extra params with defaults)
- Consolidate result types in ONE location
- ABC becomes the minimal interface, concrete extends it

**Option B: Remove ABC entirely**
- Delete abstract `Searcher` from `searcher_types.py`
- Change `ContextAssembler` to use concrete `Searcher` directly
- Less type-safe, harder to mock in tests

**Option C: Split into interface + adapter**
- Keep ABC as the minimal interface for `ContextAssembler`
- Create adapter that wraps concrete `Searcher` to conform to ABC
- More complex, possibly over-engineered

### Code Changes (Option A)

1. **File**: `src/clams/search/searcher.py`
   **Change**: Add inheritance from `context.searcher_types.Searcher`
   **Rationale**: Establishes proper type relationship

   ```python
   from clams.context.searcher_types import Searcher as SearcherABC

   class Searcher(SearcherABC):
       ...
   ```

2. **File**: `src/clams/context/searcher_types.py`
   **Change**: Remove duplicate result dataclasses, import from `search.results`
   **Rationale**: Single source of truth for result types

   Note: This may require moving result classes to avoid circular imports. Consider:
   - Move result classes to `search/results.py` (already exists)
   - Have `searcher_types.py` import and re-export from there
   - Or create a shared `types.py` module

3. **File**: `src/clams/context/searcher_types.py`
   **Change**: Update ABC signatures to match concrete methods (add optional params)
   **Rationale**: ABC should define the full interface, callers can use subset

   ```python
   @abstractmethod
   async def search_memories(
       self,
       query: str,
       category: str | None = None,
       limit: int = 20,
       search_mode: str = "semantic",
   ) -> list[MemoryResult]:
   ```

4. **File**: `tests/context/test_assembler.py`
   **Change**: Update `MockSearcher` to match new ABC signature
   **Rationale**: Tests must implement the full interface

### Regression Test

**Test file**: `tests/bugs/test_bug_041_searcher_inheritance.py`

**Test should**:
1. Verify concrete `Searcher` is instance of abstract `Searcher`
2. Verify type checking passes when passing concrete to `ContextAssembler`
3. Verify all abstract methods are implemented in concrete

**Test outline**:
```python
def test_searcher_inheritance():
    """Verify concrete Searcher inherits from abstract Searcher."""
    from clams.context.searcher_types import Searcher as SearcherABC
    from clams.search.searcher import Searcher

    # Concrete should inherit from ABC
    assert issubclass(Searcher, SearcherABC)

def test_searcher_implements_all_abstract_methods():
    """Verify concrete Searcher implements all abstract methods."""
    from clams.context.searcher_types import Searcher as SearcherABC
    from clams.search.searcher import Searcher
    from unittest.mock import MagicMock

    # Should be able to instantiate (no abstract methods unimplemented)
    embedding_service = MagicMock()
    vector_store = MagicMock()
    searcher = Searcher(embedding_service, vector_store)

    # All ABC methods should exist
    for method in ['search_memories', 'search_code', 'search_experiences',
                   'search_values', 'search_commits']:
        assert hasattr(searcher, method)
        assert callable(getattr(searcher, method))

def test_context_assembler_accepts_concrete_searcher():
    """Verify ContextAssembler type-safely accepts concrete Searcher."""
    from clams.context.assembler import ContextAssembler
    from clams.context.searcher_types import Searcher as SearcherABC
    from clams.search.searcher import Searcher
    from unittest.mock import MagicMock

    # Create concrete searcher
    embedding_service = MagicMock()
    vector_store = MagicMock()
    searcher = Searcher(embedding_service, vector_store)

    # Should be instance of ABC
    assert isinstance(searcher, SearcherABC)

    # Should be accepted by ContextAssembler
    assembler = ContextAssembler(searcher)
    assert assembler._searcher is searcher
```

### Verification

After implementing the fix:
```bash
# Run specific test
pytest tests/bugs/test_bug_041_searcher_inheritance.py -xvs

# Run related tests
pytest tests/search/test_searcher.py tests/context/test_assembler.py -xvs

# Type check
mypy --strict src/clams/context/ src/clams/search/

# Run full test suite
pytest -xvs
```

---

## Implementation (filled by Implementer)

- **Implemented by**: [worker ID]
- **Commit**: [SHA]
- **Regression test file**: [path]

### Changes Made

[Brief summary of actual changes vs plan]

---

## Review (filled by Reviewers)

| Review # | Reviewer | Result | Date |
|----------|----------|--------|------|
| 1 | [worker ID] | [approved/changes_requested] | [date] |
| 2 | [worker ID] | [approved/changes_requested] | [date] |

---

## Resolution

- **Fixed in commit**: [SHA on main]
- **Verified by**: [worker ID]
- **Closed at**: [timestamp]
