#!/usr/bin/env bash
#
# claws-session: Manage session handoffs
#
# Usage:
#   claws-session save [--continue] [--no-auto-commit]  Save handoff from stdin
#   claws-session list                                  List recent sessions
#   claws-session show <id>                             Show a session's handoff
#   claws-session next-commands                         Generate next commands for active tasks
#
# The 'save' command:
# - Reads the handoff content from stdin (raw markdown)
# - Auto-commits any staged changes in active worktrees (unless --no-auto-commit)
# - Appends auto-commit summary to handoff
# - Base64-encodes and stores in database
#
# Examples:
#   # Save a handoff (no continuation expected)
#   cat <<'EOF' | .claude/bin/claws-session save
#   # Session Handoff - 2024-01-15
#   ## Summary
#   Did some work...
#   EOF
#
#   # Save a handoff that needs continuation
#   cat <<'EOF' | .claude/bin/claws-session save --continue
#   # Session Handoff - 2024-01-15
#   ...
#   EOF

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/claws-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run claws-init first." >&2
    exit 1
fi

# Get the next action command for a task based on its phase
# Usage: get_next_action <task_id>
# Returns a bash command or comment describing the next action
get_next_action() {
    local task_id="$1"
    local phase task_type
    read -r phase task_type < <(sqlite3 "$DB_PATH" "SELECT phase, task_type FROM tasks WHERE id = '$task_id';" | tr '|' ' ')

    if [[ -z "$phase" ]]; then
        echo "# Task not found: $task_id"
        return
    fi

    if [[ "$task_type" == "bug" ]]; then
        case "$phase" in
            REPORTED)
                echo "# Dispatch bug investigator for $task_id"
                ;;
            INVESTIGATED)
                echo ".claude/bin/claws-gate check $task_id INVESTIGATED-FIXED"
                ;;
            FIXED)
                echo "# Dispatch reviewer #1 for $task_id"
                ;;
            REVIEWED)
                echo ".claude/bin/claws-gate check $task_id REVIEWED-TESTED"
                ;;
            TESTED)
                echo ".claude/bin/claws-gate check $task_id TESTED-MERGED"
                ;;
            MERGED)
                echo ".claude/bin/claws-worktree merge $task_id"
                ;;
            DONE)
                echo "# $task_id is complete"
                ;;
            *)
                echo "# Check task status: .claude/bin/claws-task show $task_id"
                ;;
        esac
    else
        # Feature task
        case "$phase" in
            SPEC)
                echo "# Dispatch spec reviewer #1 for $task_id"
                ;;
            DESIGN)
                echo "# Dispatch architect or proposal reviewer for $task_id"
                ;;
            IMPLEMENT)
                echo ".claude/bin/claws-gate check $task_id IMPLEMENT-CODE_REVIEW"
                ;;
            CODE_REVIEW)
                echo "# Dispatch code reviewer for $task_id"
                ;;
            TEST)
                echo ".claude/bin/claws-gate check $task_id TEST-INTEGRATE"
                ;;
            INTEGRATE)
                echo ".claude/bin/claws-worktree merge $task_id"
                ;;
            VERIFY)
                echo "# Verify acceptance criteria and transition to DONE: $task_id"
                ;;
            DONE)
                echo "# $task_id is complete"
                ;;
            *)
                echo "# Check task status: .claude/bin/claws-task show $task_id"
                ;;
        esac
    fi
}

# Get description of next action for a task (human-readable)
# Usage: describe_next_action <task_id>
describe_next_action() {
    local task_id="$1"
    local phase task_type
    read -r phase task_type < <(sqlite3 "$DB_PATH" "SELECT phase, task_type FROM tasks WHERE id = '$task_id';" | tr '|' ' ')

    if [[ -z "$phase" ]]; then
        echo "Task not found"
        return
    fi

    if [[ "$task_type" == "bug" ]]; then
        case "$phase" in
            REPORTED) echo "Dispatch bug investigator" ;;
            INVESTIGATED) echo "Run gate check and transition to FIXED" ;;
            FIXED) echo "Dispatch reviewer #1" ;;
            REVIEWED) echo "Run gate check and transition to TESTED" ;;
            TESTED) echo "Run gate check and transition to MERGED" ;;
            MERGED) echo "Merge to main and verify" ;;
            DONE) echo "Complete" ;;
            *) echo "Check task status" ;;
        esac
    else
        case "$phase" in
            SPEC) echo "Dispatch spec reviewer #1" ;;
            DESIGN) echo "Dispatch architect or proposal reviewer" ;;
            IMPLEMENT) echo "Run gate check and transition to CODE_REVIEW" ;;
            CODE_REVIEW) echo "Dispatch code reviewer #1" ;;
            TEST) echo "Run gate check and transition to INTEGRATE" ;;
            INTEGRATE) echo "Merge to main" ;;
            VERIFY) echo "Verify acceptance criteria" ;;
            DONE) echo "Complete" ;;
            *) echo "Check task status" ;;
        esac
    fi
}

# Generate next commands section for active tasks
# Usage: generate_next_commands
# Outputs markdown with copy-paste ready commands
generate_next_commands() {
    # Get active tasks (not DONE)
    local active_tasks
    active_tasks=$(sqlite3 "$DB_PATH" "SELECT id FROM tasks WHERE phase != 'DONE' ORDER BY updated_at DESC;")

    if [[ -z "$active_tasks" ]]; then
        echo "## Next Commands"
        echo ""
        echo "No active tasks."
        return
    fi

    # Find highest priority task (most recently updated non-DONE task)
    local priority_task
    priority_task=$(echo "$active_tasks" | head -1)

    echo "## Next Commands"
    echo ""
    echo "Execute these commands to continue work:"
    echo ""
    echo '```bash'
    echo "# Resume task $priority_task"
    echo ".claude/bin/claws-task show $priority_task"

    # Get worktree path if exists
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$priority_task';")
    if [[ -n "$worktree_path" && "$worktree_path" != "NULL" ]]; then
        echo "cd $worktree_path"
    fi

    echo ""
    echo "# Next action based on phase"
    get_next_action "$priority_task"
    echo '```'

    echo ""
    echo "## Pending Actions"
    echo ""

    # List all active tasks with their next actions
    while IFS= read -r task_id; do
        if [[ -n "$task_id" ]]; then
            local phase
            phase=$(sqlite3 "$DB_PATH" "SELECT phase FROM tasks WHERE id = '$task_id';")
            local description
            description=$(describe_next_action "$task_id")
            echo "- **$task_id** ($phase): $description"
        fi
    done <<< "$active_tasks"
}

cmd_next_commands() {
    generate_next_commands
}

cmd_save() {
    local needs_continuation=0
    local auto_commit=1

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --continue)
                needs_continuation=1
                shift
                ;;
            --no-auto-commit)
                auto_commit=0
                shift
                ;;
            *)
                echo "Error: Unknown argument: $1" >&2
                echo "Usage: claws-session save [--continue] [--no-auto-commit]" >&2
                exit 1
                ;;
        esac
    done

    # Auto-commit staged changes in all active worktrees
    local auto_committed_worktrees=""
    local worktrees_with_unstaged=""

    if [[ "$auto_commit" -eq 1 ]] && [[ -d "$WORKTREE_DIR" ]]; then
        echo "Checking for uncommitted changes in worktrees..."

        for worktree in "$WORKTREE_DIR"/*; do
            if [[ -d "$worktree" ]]; then
                local task_id
                task_id=$(basename "$worktree")

                # Check for staged changes
                if ! git -C "$worktree" diff --cached --quiet 2>/dev/null; then
                    local staged_count
                    staged_count=$(git -C "$worktree" diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
                    echo "Auto-committing staged changes in $task_id ($staged_count files)"

                    git -C "$worktree" commit -m "WIP: Auto-commit at session end

This commit was auto-generated by claws-session save.
Staged changes were present when session ended."

                    if [[ -z "$auto_committed_worktrees" ]]; then
                        auto_committed_worktrees="- $task_id: $staged_count files auto-committed"
                    else
                        auto_committed_worktrees="$auto_committed_worktrees
- $task_id: $staged_count files auto-committed"
                    fi
                fi

                # Warn about unstaged changes (don't auto-add)
                if ! git -C "$worktree" diff --quiet 2>/dev/null; then
                    echo "WARNING: $task_id has unstaged changes (not auto-committed)"
                    if [[ -z "$worktrees_with_unstaged" ]]; then
                        worktrees_with_unstaged="- $task_id"
                    else
                        worktrees_with_unstaged="$worktrees_with_unstaged
- $task_id"
                    fi
                fi
            fi
        done

        if [[ -z "$auto_committed_worktrees" ]]; then
            echo "No staged changes found in any worktree."
        fi
    fi

    # Read content from stdin
    local content
    content=$(cat)

    if [[ -z "$content" ]]; then
        echo "Error: No content provided. Pipe handoff content to stdin." >&2
        echo "Example: cat handoff.md | claws-session save" >&2
        exit 1
    fi

    # Append auto-commit and unstaged sections to handoff content
    if [[ -n "$auto_committed_worktrees" ]]; then
        content="$content

## Auto-Committed Worktrees
$auto_committed_worktrees"
    fi

    if [[ -n "$worktrees_with_unstaged" ]]; then
        content="$content

## Worktrees with Unstaged Changes
$worktrees_with_unstaged"
    fi

    # Generate UUID (works on macOS and Linux)
    local session_id
    if command -v uuidgen &>/dev/null; then
        session_id=$(uuidgen | tr '[:upper:]' '[:lower:]')
    elif [[ -f /proc/sys/kernel/random/uuid ]]; then
        session_id=$(cat /proc/sys/kernel/random/uuid)
    else
        # Fallback: use date + random
        session_id=$(date +%s)-$$-$RANDOM
    fi

    # Base64 encode the content
    local encoded_content
    encoded_content=$(echo "$content" | base64)

    # Insert into database
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO sessions (id, created_at, handoff_content, needs_continuation)
VALUES ('$session_id', datetime('now'), '$encoded_content', $needs_continuation);
EOF

    echo "Session saved: $session_id"
    if [[ "$needs_continuation" -eq 1 ]]; then
        echo "Marked for continuation (next session will see handoff)"
    else
        echo "Archived (no continuation expected)"
    fi
}

cmd_list() {
    echo "=== Recent Sessions ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT
    id,
    created_at,
    CASE WHEN needs_continuation THEN 'yes' ELSE 'no' END as needs_continue,
    CASE WHEN resumed_at IS NOT NULL THEN resumed_at ELSE '-' END as resumed_at
FROM sessions
ORDER BY created_at DESC
LIMIT 10;
EOF
}

cmd_show() {
    local session_id="$1"

    if [[ -z "$session_id" ]]; then
        echo "Error: Session ID required" >&2
        echo "Usage: claws-session show <id>" >&2
        exit 1
    fi

    local encoded_content
    encoded_content=$(sqlite3 "$DB_PATH" "SELECT handoff_content FROM sessions WHERE id = '$session_id';")

    if [[ -z "$encoded_content" ]]; then
        echo "Error: Session not found: $session_id" >&2
        exit 1
    fi

    echo "=== Session: $session_id ==="
    echo "$encoded_content" | base64 -d
}

# Main
command="${1:-}"

case "$command" in
    save)
        shift
        cmd_save "$@"
        ;;
    list)
        cmd_list
        ;;
    show)
        shift
        cmd_show "${1:-}"
        ;;
    next-commands)
        cmd_next_commands
        ;;
    *)
        echo "Usage:"
        echo "  claws-session save [--continue] [--no-auto-commit]  Save handoff from stdin"
        echo "  claws-session list                                  List recent sessions"
        echo "  claws-session show <id>                             Show a session's handoff"
        echo "  claws-session next-commands                         Generate next commands for active tasks"
        echo ""
        echo "Examples:"
        echo "  # Save handoff (pipe markdown content to stdin)"
        echo "  cat <<'EOF' | .claude/bin/claws-session save"
        echo "  # Session Handoff"
        echo "  ## Summary"
        echo "  Did some work..."
        echo "  EOF"
        echo ""
        echo "  # Save with continuation flag"
        echo "  cat <<'EOF' | .claude/bin/claws-session save --continue"
        echo "  ..."
        echo "  EOF"
        echo ""
        echo "  # Generate next commands for current tasks"
        echo "  .claude/bin/claws-session next-commands"
        exit 1
        ;;
esac
