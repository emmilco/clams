#!/usr/bin/env bash
#
# claws-session: Manage session handoffs
#
# Usage:
#   claws-session save [--continue] [--no-auto-commit]  Save handoff from stdin
#   claws-session list                                  List recent sessions
#   claws-session show <id>                             Show a specific session's handoff
#
# The 'save' command:
# - Reads the handoff content from stdin (raw markdown)
# - Auto-commits any staged changes in active worktrees (unless --no-auto-commit)
# - Appends auto-commit summary to handoff
# - Base64-encodes and stores in database
#
# Examples:
#   # Save a handoff (no continuation expected)
#   cat <<'EOF' | .claude/bin/claws-session save
#   # Session Handoff - 2024-01-15
#   ## Summary
#   Did some work...
#   EOF
#
#   # Save a handoff that needs continuation
#   cat <<'EOF' | .claude/bin/claws-session save --continue
#   # Session Handoff - 2024-01-15
#   ...
#   EOF

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/claws-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run claws-init first." >&2
    exit 1
fi

cmd_save() {
    local needs_continuation=0
    local auto_commit=1

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --continue)
                needs_continuation=1
                shift
                ;;
            --no-auto-commit)
                auto_commit=0
                shift
                ;;
            *)
                echo "Error: Unknown argument: $1" >&2
                echo "Usage: claws-session save [--continue] [--no-auto-commit]" >&2
                exit 1
                ;;
        esac
    done

    # Auto-commit staged changes in all active worktrees
    local auto_committed_worktrees=""
    local worktrees_with_unstaged=""

    if [[ "$auto_commit" -eq 1 ]] && [[ -d "$WORKTREE_DIR" ]]; then
        echo "Checking for uncommitted changes in worktrees..."

        for worktree in "$WORKTREE_DIR"/*; do
            if [[ -d "$worktree" ]]; then
                local task_id
                task_id=$(basename "$worktree")

                # Check for staged changes
                if ! git -C "$worktree" diff --cached --quiet 2>/dev/null; then
                    local staged_count
                    staged_count=$(git -C "$worktree" diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
                    echo "Auto-committing staged changes in $task_id ($staged_count files)"

                    git -C "$worktree" commit -m "WIP: Auto-commit at session end

This commit was auto-generated by claws-session save.
Staged changes were present when session ended."

                    if [[ -z "$auto_committed_worktrees" ]]; then
                        auto_committed_worktrees="- $task_id: $staged_count files auto-committed"
                    else
                        auto_committed_worktrees="$auto_committed_worktrees
- $task_id: $staged_count files auto-committed"
                    fi
                fi

                # Warn about unstaged changes (don't auto-add)
                if ! git -C "$worktree" diff --quiet 2>/dev/null; then
                    echo "WARNING: $task_id has unstaged changes (not auto-committed)"
                    if [[ -z "$worktrees_with_unstaged" ]]; then
                        worktrees_with_unstaged="- $task_id"
                    else
                        worktrees_with_unstaged="$worktrees_with_unstaged
- $task_id"
                    fi
                fi
            fi
        done

        if [[ -z "$auto_committed_worktrees" ]]; then
            echo "No staged changes found in any worktree."
        fi
    fi

    # Read content from stdin
    local content
    content=$(cat)

    if [[ -z "$content" ]]; then
        echo "Error: No content provided. Pipe handoff content to stdin." >&2
        echo "Example: cat handoff.md | claws-session save" >&2
        exit 1
    fi

    # Append auto-commit and unstaged sections to handoff content
    if [[ -n "$auto_committed_worktrees" ]]; then
        content="$content

## Auto-Committed Worktrees
$auto_committed_worktrees"
    fi

    if [[ -n "$worktrees_with_unstaged" ]]; then
        content="$content

## Worktrees with Unstaged Changes
$worktrees_with_unstaged"
    fi

    # Generate UUID (works on macOS and Linux)
    local session_id
    if command -v uuidgen &>/dev/null; then
        session_id=$(uuidgen | tr '[:upper:]' '[:lower:]')
    elif [[ -f /proc/sys/kernel/random/uuid ]]; then
        session_id=$(cat /proc/sys/kernel/random/uuid)
    else
        # Fallback: use date + random
        session_id=$(date +%s)-$$-$RANDOM
    fi

    # Base64 encode the content
    local encoded_content
    encoded_content=$(echo "$content" | base64)

    # Insert into database
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO sessions (id, created_at, handoff_content, needs_continuation)
VALUES ('$session_id', datetime('now'), '$encoded_content', $needs_continuation);
EOF

    echo "Session saved: $session_id"
    if [[ "$needs_continuation" -eq 1 ]]; then
        echo "Marked for continuation (next session will see handoff)"
    else
        echo "Archived (no continuation expected)"
    fi
}

cmd_list() {
    echo "=== Recent Sessions ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT
    id,
    created_at,
    CASE WHEN needs_continuation THEN 'yes' ELSE 'no' END as needs_continue,
    CASE WHEN resumed_at IS NOT NULL THEN resumed_at ELSE '-' END as resumed_at
FROM sessions
ORDER BY created_at DESC
LIMIT 10;
EOF
}

cmd_show() {
    local session_id="$1"

    if [[ -z "$session_id" ]]; then
        echo "Error: Session ID required" >&2
        echo "Usage: claws-session show <id>" >&2
        exit 1
    fi

    local encoded_content
    encoded_content=$(sqlite3 "$DB_PATH" "SELECT handoff_content FROM sessions WHERE id = '$session_id';")

    if [[ -z "$encoded_content" ]]; then
        echo "Error: Session not found: $session_id" >&2
        exit 1
    fi

    echo "=== Session: $session_id ==="
    echo "$encoded_content" | base64 -d
}

# Main
command="${1:-}"

case "$command" in
    save)
        shift
        cmd_save "$@"
        ;;
    list)
        cmd_list
        ;;
    show)
        shift
        cmd_show "${1:-}"
        ;;
    *)
        echo "Usage:"
        echo "  claws-session save [--continue] [--no-auto-commit]  Save handoff from stdin"
        echo "  claws-session list                                  List recent sessions"
        echo "  claws-session show <id>                             Show a session's handoff"
        echo ""
        echo "Examples:"
        echo "  # Save handoff (pipe markdown content to stdin)"
        echo "  cat <<'EOF' | .claude/bin/claws-session save"
        echo "  # Session Handoff"
        echo "  ## Summary"
        echo "  Did some work..."
        echo "  EOF"
        echo ""
        echo "  # Save with continuation flag"
        echo "  cat <<'EOF' | .claude/bin/claws-session save --continue"
        echo "  ..."
        echo "  EOF"
        exit 1
        ;;
esac
