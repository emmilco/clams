#!/usr/bin/env bash
#
# clams-task: Task CRUD operations
#
# Usage:
#   clams-task create <id> <title> [--spec <spec_id>] [--type <feature|bug>]
#   clams-task list [--phase <phase>] [--spec <spec_id>] [--type <feature|bug>]
#   clams-task show <id>
#   clams-task update <id> --phase <phase>
#   clams-task update <id> --specialist <specialist>
#   clams-task update <id> --blocked-by <task_id>
#   clams-task update <id> --notes <notes>
#   clams-task update <id> --worktree <path>
#   clams-task transition <id> <to_phase> [--gate-result <pass|fail>] [--gate-details <details>]
#   clams-task delete <id>
#
# Task types:
#   feature (default): SPEC → DESIGN → IMPLEMENT → CODE_REVIEW → TEST → INTEGRATE → VERIFY → DONE
#   bug: REPORTED → INVESTIGATED → FIXED → REVIEWED → TESTED → MERGED → DONE

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/clams-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run clams-init first." >&2
    exit 1
fi

usage() {
    echo "Usage:"
    echo "  clams-task create <id> <title> [--spec <spec_id>] [--type <feature|bug>]"
    echo "  clams-task list [--phase <phase>] [--spec <spec_id>] [--type <feature|bug>]"
    echo "  clams-task show <id>"
    echo "  clams-task update <id> <--field value>..."
    echo "  clams-task transition <id> <to_phase> [--gate-result <result>] [--gate-details <details>]"
    echo "  clams-task delete <id>"
    echo ""
    echo "Task types:"
    echo "  feature (default): SPEC → DESIGN → IMPLEMENT → CODE_REVIEW → TEST → INTEGRATE → VERIFY → DONE"
    echo "  bug: REPORTED → INVESTIGATED → FIXED → REVIEWED → TESTED → MERGED → DONE"
    exit 1
}

cmd_create() {
    local id="$1"
    local title="$2"
    shift 2

    local spec_id=""
    local task_type="feature"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --spec)
                spec_id="$2"
                shift 2
                ;;
            --type)
                task_type="$2"
                if [[ "$task_type" != "feature" && "$task_type" != "bug" ]]; then
                    echo "Error: Invalid task type '$task_type'. Must be 'feature' or 'bug'." >&2
                    exit 1
                fi
                shift 2
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    # Set initial phase based on task type
    local initial_phase="SPEC"
    if [[ "$task_type" == "bug" ]]; then
        initial_phase="REPORTED"
    fi

    sqlite3 "$DB_PATH" <<EOF
INSERT INTO tasks (id, title, spec_id, task_type, phase)
VALUES ('$id', '$(echo "$title" | sed "s/'/''/g")', $([ -n "$spec_id" ] && echo "'$spec_id'" || echo "NULL"), '$task_type', '$initial_phase');
EOF

    echo "Created $task_type: $id (phase: $initial_phase)"
}

cmd_list() {
    local phase=""
    local spec_id=""
    local task_type=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --phase)
                phase="$2"
                shift 2
                ;;
            --spec)
                spec_id="$2"
                shift 2
                ;;
            --type)
                task_type="$2"
                shift 2
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    local where_clauses=()
    if [[ -n "$phase" ]]; then
        where_clauses+=("phase = '$phase'")
    fi
    if [[ -n "$spec_id" ]]; then
        where_clauses+=("spec_id = '$spec_id'")
    fi
    if [[ -n "$task_type" ]]; then
        where_clauses+=("task_type = '$task_type'")
    fi

    local where_clause=""
    if [[ ${#where_clauses[@]} -gt 0 ]]; then
        where_clause="WHERE $(IFS=' AND '; echo "${where_clauses[*]}")"
    fi

    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT id, title, task_type, phase, assigned_specialist, blocked_by
FROM tasks
$where_clause
ORDER BY created_at DESC;
EOF
}

cmd_show() {
    local id="$1"

    echo "=== Task: $id ==="
    sqlite3 -line "$DB_PATH" <<EOF
SELECT * FROM tasks WHERE id = '$id';
EOF

    echo ""
    echo "=== Phase History ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT from_phase, to_phase, gate_result, transitioned_at
FROM phase_transitions
WHERE task_id = '$id'
ORDER BY transitioned_at;
EOF

    echo ""
    echo "=== Test Runs ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT run_at, total_tests, passed, failed, errors, execution_time_seconds
FROM test_runs
WHERE task_id = '$id'
ORDER BY run_at DESC
LIMIT 5;
EOF
}

cmd_update() {
    local id="$1"
    shift

    local updates=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --phase)
                updates+=("phase = '$2'")
                shift 2
                ;;
            --specialist)
                updates+=("assigned_specialist = '$2'")
                shift 2
                ;;
            --blocked-by)
                if [[ "$2" == "NULL" || "$2" == "null" || "$2" == "" ]]; then
                    updates+=("blocked_by = NULL")
                else
                    updates+=("blocked_by = '$2'")
                fi
                shift 2
                ;;
            --notes)
                updates+=("notes = '$(echo "$2" | sed "s/'/''/g")'")
                shift 2
                ;;
            --worktree)
                updates+=("worktree_path = '$2'")
                shift 2
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    if [[ ${#updates[@]} -eq 0 ]]; then
        echo "No updates specified" >&2
        usage
    fi

    local update_str
    update_str=$(IFS=', '; echo "${updates[*]}")

    sqlite3 "$DB_PATH" <<EOF
UPDATE tasks
SET $update_str, updated_at = CURRENT_TIMESTAMP
WHERE id = '$id';
EOF

    echo "Updated task: $id"
}

cmd_transition() {
    local id="$1"
    local to_phase="$2"
    shift 2

    local gate_result=""
    local gate_details=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --gate-result)
                gate_result="$2"
                shift 2
                ;;
            --gate-details)
                gate_details="$2"
                shift 2
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    # Get current phase and task type
    local from_phase task_type
    read -r from_phase task_type < <(sqlite3 "$DB_PATH" "SELECT phase, task_type FROM tasks WHERE id = '$id';" | tr '|' ' ')

    if [[ -z "$from_phase" ]]; then
        echo "Error: Task not found: $id" >&2
        exit 1
    fi

    # Validate phase transition is valid for task type
    local valid_transition=false
    if [[ "$task_type" == "bug" ]]; then
        case "${from_phase}-${to_phase}" in
            REPORTED-INVESTIGATED|INVESTIGATED-FIXED|FIXED-REVIEWED|REVIEWED-TESTED|TESTED-MERGED|MERGED-DONE)
                valid_transition=true
                ;;
        esac
        if [[ "$valid_transition" == "false" ]]; then
            echo "Error: Invalid bug transition: $from_phase → $to_phase" >&2
            echo "Valid bug transitions: REPORTED→INVESTIGATED→FIXED→REVIEWED→TESTED→MERGED→DONE" >&2
            exit 1
        fi
    else
        case "${from_phase}-${to_phase}" in
            SPEC-DESIGN|DESIGN-IMPLEMENT|IMPLEMENT-CODE_REVIEW|CODE_REVIEW-TEST|TEST-INTEGRATE|INTEGRATE-VERIFY|VERIFY-DONE)
                valid_transition=true
                ;;
        esac
        if [[ "$valid_transition" == "false" ]]; then
            echo "Error: Invalid feature transition: $from_phase → $to_phase" >&2
            echo "Valid feature transitions: SPEC→DESIGN→IMPLEMENT→CODE_REVIEW→TEST→INTEGRATE→VERIFY→DONE" >&2
            exit 1
        fi
    fi

    # Get worktree path for implementation checks
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$id';")

    # Enforce implementation exists for IMPLEMENT → CODE_REVIEW
    if [[ "${from_phase}-${to_phase}" == "IMPLEMENT-CODE_REVIEW" ]]; then
        if [[ -z "$worktree_path" || ! -d "$worktree_path" ]]; then
            echo "Error: No worktree found for task $id" >&2
            exit 1
        fi

        # Check for actual code changes (not just docs)
        local code_changes
        code_changes=$(cd "$worktree_path" && git diff main...HEAD --name-only -- 'src/' 'tests/' 2>/dev/null | grep -v '__pycache__' | head -5)

        if [[ -z "$code_changes" ]]; then
            echo "Error: IMPLEMENT → CODE_REVIEW requires implementation code" >&2
            echo "" >&2
            echo "No changes found in src/ or tests/ directories." >&2
            echo "The task appears to have only documentation changes." >&2
            echo "" >&2
            echo "Run 'git diff main...HEAD --stat' in the worktree to see what changed." >&2
            exit 1
        fi

        echo "✓ Implementation check passed. Changed files:"
        echo "$code_changes" | sed 's/^/  /'
    fi

    # Enforce review requirements for specific transitions
    # Reviews must be recorded in the database before transition is allowed
    local required_reviews=""
    local artifact_type=""

    case "${from_phase}-${to_phase}" in
        # Feature review gates
        SPEC-DESIGN)
            artifact_type="spec"
            required_reviews=2
            ;;
        DESIGN-IMPLEMENT)
            artifact_type="proposal"
            required_reviews=2
            ;;
        CODE_REVIEW-TEST)
            artifact_type="code"
            required_reviews=2
            ;;
        # Bug review gates
        FIXED-REVIEWED)
            artifact_type="bugfix"
            required_reviews=2
            ;;
    esac

    if [[ -n "$required_reviews" ]]; then
        local approved_count
        approved_count=$(sqlite3 "$DB_PATH" \
            "SELECT COUNT(*) FROM reviews
             WHERE task_id = '$id'
             AND artifact_type = '$artifact_type'
             AND result = 'approved';")

        if [[ "$approved_count" -lt "$required_reviews" ]]; then
            echo "Error: $from_phase → $to_phase requires $required_reviews approved $artifact_type reviews" >&2
            echo "" >&2
            echo "Current status: $approved_count/$required_reviews approved" >&2
            echo "" >&2
            echo "Reviews must be recorded in the database before transition." >&2
            echo "Record reviews with:" >&2
            echo "  .claude/bin/clams-review record $id $artifact_type approved --worker <worker_id>" >&2
            exit 1
        fi

        echo "✓ Review gate passed: $approved_count/$required_reviews $artifact_type reviews approved"
    fi

    # Record transition
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO phase_transitions (task_id, from_phase, to_phase, gate_result, gate_details)
VALUES ('$id', '$from_phase', '$to_phase',
        $([ -n "$gate_result" ] && echo "'$gate_result'" || echo "NULL"),
        $([ -n "$gate_details" ] && echo "'$(echo "$gate_details" | sed "s/'/''/g")'" || echo "NULL"));

UPDATE tasks
SET phase = '$to_phase', updated_at = CURRENT_TIMESTAMP
WHERE id = '$id';
EOF

    echo "Transitioned $id: $from_phase -> $to_phase"
}

cmd_delete() {
    local id="$1"

    # Auto-backup before destructive operation
    "$SCRIPT_DIR/clams-backup" auto 2>/dev/null || true

    # Check for worktree and remove if exists
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$id';")

    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
        echo "Removing worktree: $worktree_path"
        cd "$MAIN_REPO"
        git worktree remove "$worktree_path" --force 2>/dev/null || true
        # Remove branch if it exists
        git branch -D "$id" 2>/dev/null || true
    fi

    sqlite3 "$DB_PATH" <<EOF
DELETE FROM phase_transitions WHERE task_id = '$id';
DELETE FROM test_runs WHERE task_id = '$id';
DELETE FROM violations WHERE task_id = '$id';
DELETE FROM merge_log WHERE task_id = '$id';
DELETE FROM tasks WHERE id = '$id';
EOF

    echo "Deleted task: $id"
}

# Main
if [[ $# -lt 1 ]]; then
    usage
fi

command="$1"
shift

case "$command" in
    create)
        [[ $# -lt 2 ]] && usage
        cmd_create "$@"
        ;;
    list)
        cmd_list "$@"
        ;;
    show)
        [[ $# -lt 1 ]] && usage
        cmd_show "$@"
        ;;
    update)
        [[ $# -lt 2 ]] && usage
        cmd_update "$@"
        ;;
    transition)
        [[ $# -lt 2 ]] && usage
        cmd_transition "$@"
        ;;
    delete)
        [[ $# -lt 1 ]] && usage
        cmd_delete "$@"
        ;;
    *)
        echo "Unknown command: $command" >&2
        usage
        ;;
esac
