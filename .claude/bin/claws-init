#!/usr/bin/env bash
#
# claws-init: Initialize the CLAMS database
#
# Usage: claws-init
#
# Creates .claude/claws.db with the required schema.
# Safe to run multiple times (uses IF NOT EXISTS).

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLAUDE_DIR="$(dirname "$SCRIPT_DIR")"
DB_PATH="$CLAUDE_DIR/claws.db"

echo "Initializing CLAMS database at $DB_PATH"

sqlite3 "$DB_PATH" <<'EOF'
-- Tasks
-- task_type: 'feature' (default) or 'bug'
-- Feature phases: SPEC → DESIGN → IMPLEMENT → CODE_REVIEW → TEST → INTEGRATE → VERIFY → DONE
-- Bug phases: REPORTED → INVESTIGATED → FIXED → REVIEWED → TESTED → MERGED → DONE
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    spec_id TEXT,
    title TEXT NOT NULL,
    task_type TEXT NOT NULL DEFAULT 'feature',
    phase TEXT NOT NULL DEFAULT 'SPEC',
    assigned_specialist TEXT,
    worktree_path TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    blocked_by TEXT,
    notes TEXT
);

-- Phase transitions (audit log)
CREATE TABLE IF NOT EXISTS phase_transitions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    from_phase TEXT,
    to_phase TEXT NOT NULL,
    gate_result TEXT,
    gate_details TEXT,
    transitioned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);

-- Workers
CREATE TABLE IF NOT EXISTS workers (
    id TEXT PRIMARY KEY,
    specialist_type TEXT NOT NULL,
    current_task_id TEXT,
    status TEXT NOT NULL DEFAULT 'idle',
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    FOREIGN KEY (current_task_id) REFERENCES tasks(id)
);

-- Merge log
CREATE TABLE IF NOT EXISTS merge_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    merged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    merge_commit TEXT,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);

-- Test runs
CREATE TABLE IF NOT EXISTS test_runs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    worktree TEXT,
    commit_sha TEXT,
    total_tests INTEGER,
    passed INTEGER,
    failed INTEGER,
    errors INTEGER,
    skipped INTEGER,
    test_files INTEGER,
    execution_time_seconds REAL,
    failed_tests TEXT,
    run_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);

-- Reviews (for multi-review gates)
CREATE TABLE IF NOT EXISTS reviews (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    artifact_type TEXT NOT NULL,  -- 'spec', 'proposal', 'code'
    review_num INTEGER NOT NULL,  -- 1 or 2
    reviewer_worker_id TEXT,
    result TEXT NOT NULL,         -- 'approved', 'changes_requested'
    issues_found TEXT,            -- JSON array of issues if any
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(id),
    UNIQUE(task_id, artifact_type, review_num)
);

-- Violations (for pattern analysis)
CREATE TABLE IF NOT EXISTS violations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT,
    worker_id TEXT,
    violation_type TEXT NOT NULL,
    description TEXT,
    root_cause TEXT,
    prevention TEXT,
    detected_by TEXT,
    detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(id),
    FOREIGN KEY (worker_id) REFERENCES workers(id)
);

-- System counters (for batch triggers)
CREATE TABLE IF NOT EXISTS system_counters (
    name TEXT PRIMARY KEY,
    value INTEGER NOT NULL DEFAULT 0
);

-- Initialize counters if they don't exist
INSERT OR IGNORE INTO system_counters (name, value) VALUES ('merges_since_e2e', 0);
INSERT OR IGNORE INTO system_counters (name, value) VALUES ('merges_since_docs', 0);
INSERT OR IGNORE INTO system_counters (name, value) VALUES ('merge_lock', 0);

-- Create indexes for common queries
CREATE INDEX IF NOT EXISTS idx_tasks_phase ON tasks(phase);
CREATE INDEX IF NOT EXISTS idx_tasks_spec_id ON tasks(spec_id);
CREATE INDEX IF NOT EXISTS idx_phase_transitions_task ON phase_transitions(task_id);
CREATE INDEX IF NOT EXISTS idx_test_runs_task ON test_runs(task_id);
CREATE INDEX IF NOT EXISTS idx_violations_task ON violations(task_id);
CREATE INDEX IF NOT EXISTS idx_reviews_task ON reviews(task_id);
CREATE INDEX IF NOT EXISTS idx_reviews_artifact ON reviews(task_id, artifact_type);

-- Gate passes (for commit-anchored gate verification)
-- Records when a gate check passes, anchored to the commit SHA at that time.
-- Transitions verify the current commit matches the recorded commit.
CREATE TABLE IF NOT EXISTS gate_passes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    transition TEXT NOT NULL,
    commit_sha TEXT NOT NULL,
    passed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(task_id, transition, commit_sha)
);

CREATE INDEX IF NOT EXISTS idx_gate_passes_task ON gate_passes(task_id, transition);

-- Sessions (for handoff tracking)
-- Stores session handoffs with optional continuation flag
CREATE TABLE IF NOT EXISTS sessions (
    id TEXT PRIMARY KEY,              -- UUID, generated at /wrapup time
    created_at TEXT NOT NULL,         -- when /wrapup was called
    handoff_content TEXT,             -- the markdown summary
    needs_continuation BOOLEAN DEFAULT 0,
    resumed_at TEXT                   -- when next session picked it up (null = unread)
);

CREATE INDEX IF NOT EXISTS idx_sessions_pending ON sessions(needs_continuation, resumed_at);

-- Migration: Add task_type column if it doesn't exist (for existing databases)
-- SQLite doesn't have IF NOT EXISTS for ALTER TABLE, so we check first
EOF

# Add task_type column if missing (migration for existing databases)
if ! sqlite3 "$DB_PATH" "PRAGMA table_info(tasks);" | grep -q "task_type"; then
    echo "Migrating: Adding task_type column to tasks table..."
    sqlite3 "$DB_PATH" "ALTER TABLE tasks ADD COLUMN task_type TEXT NOT NULL DEFAULT 'feature';"
fi

echo "Database initialized successfully."
echo ""
echo "Tables created:"
sqlite3 "$DB_PATH" ".tables"
