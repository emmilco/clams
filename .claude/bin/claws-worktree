#!/usr/bin/env bash
#
# claws-worktree: Git worktree lifecycle management
#
# Usage:
#   claws-worktree create <task_id>       Create worktree for task
#   claws-worktree remove <task_id>       Remove worktree (no merge)
#   claws-worktree list                   List all worktrees
#   claws-worktree merge <task_id> [--skip-sync] [--check-only] [--force]
#                                         Merge to main and cleanup
#   claws-worktree path <task_id>         Print worktree path
#   claws-worktree health [--fix]         Audit worktree health

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/claws-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run claws-init first." >&2
    exit 1
fi

usage() {
    echo "Usage:"
    echo "  claws-worktree create <task_id> [--check-overlaps] [--force]"
    echo "                                    Create worktree for task"
    echo "                                    --check-overlaps: Warn about file conflicts with other worktrees"
    echo "                                    --force: Bypass overlap warnings"
    echo "  claws-worktree remove <task_id>   Remove worktree (no merge)"
    echo "  claws-worktree list               List all worktrees"
    echo "  claws-worktree merge <task_id> [--skip-sync] [--check-only] [--force]"
    echo "                                    Merge to main and cleanup"
    echo "    --skip-sync: Skip dependency sync after merge"
    echo "    --check-only: Only check for conflicts, don't merge"
    echo "    --force: Attempt merge even if conflicts detected"
    echo "  claws-worktree path <task_id>     Print worktree path"
    echo "  claws-worktree health [--fix]     Audit worktree health"
    exit 1
}

# Check for potential file overlaps with other worktrees
# Returns: 0 if overlaps found (printed to stdout), 1 if no overlaps
# This function lists files being modified in other worktrees so the
# orchestrator can assess potential conflicts before starting new work.
check_overlaps() {
    local overlaps_found=1

    # Check each existing worktree for uncommitted changes and planned modifications
    local worktrees
    worktrees=$(git worktree list --porcelain | grep "^worktree " | sed 's/^worktree //')

    for wt in $worktrees; do
        # Skip main repo
        [[ "$wt" == "$MAIN_REPO" ]] && continue

        # Get task ID from worktree path
        local wt_task_id
        wt_task_id=$(basename "$wt")

        # Skip if it's not in our .worktrees directory
        [[ ! "$wt" == "$WORKTREE_DIR/"* ]] && continue

        # Get uncommitted changes in this worktree
        local changed_files=""
        if [[ -d "$wt" ]]; then
            # Get both staged and unstaged changes (excluding planning docs and changelog)
            changed_files=$(cd "$wt" && git diff --name-only 2>/dev/null; cd "$wt" && git diff --cached --name-only 2>/dev/null)
            changed_files=$(echo "$changed_files" | grep -v "^planning_docs/" | grep -v "^bug_reports/" | grep -v "^changelog.d/" | sort -u || true)
        fi

        # Also check what files are mentioned in this worktree's planning docs
        local wt_mentioned_files=""
        if [[ -d "$wt/planning_docs/$wt_task_id" ]]; then
            wt_mentioned_files=$(grep -hEo '(src|tests|\.claude/bin)/[a-zA-Z0-9_./-]+\.(py|ts|js|sh)' \
                "$wt/planning_docs/$wt_task_id"/*.md 2>/dev/null | sort -u || true)
        fi
        if [[ -d "$wt/bug_reports" ]]; then
            local bug_files
            bug_files=$(grep -hEo '(src|tests|\.claude/bin)/[a-zA-Z0-9_./-]+\.(py|ts|js|sh)' \
                "$wt/bug_reports"/*.md 2>/dev/null | sort -u || true)
            if [[ -n "$bug_files" ]]; then
                wt_mentioned_files="$wt_mentioned_files"$'\n'"$bug_files"
            fi
        fi
        wt_mentioned_files=$(echo "$wt_mentioned_files" | sort -u | grep -v "^$" || true)

        # Report if this worktree has any active changes
        if [[ -n "$changed_files" ]]; then
            if [[ $overlaps_found -eq 1 ]]; then
                echo "Active worktrees with uncommitted changes:"
                overlaps_found=0
            fi
            echo ""
            echo "  $wt_task_id:"
            echo "$changed_files" | while read -r file; do
                [[ -n "$file" ]] && echo "    - $file (uncommitted)"
            done
        fi

        # Report files mentioned in planning docs (planned modifications)
        if [[ -n "$wt_mentioned_files" ]]; then
            if [[ $overlaps_found -eq 1 ]]; then
                echo "Active worktrees with planned modifications:"
                overlaps_found=0
            elif [[ -z "$changed_files" ]]; then
                echo ""
                echo "  $wt_task_id:"
            fi
            echo "$wt_mentioned_files" | while read -r file; do
                [[ -n "$file" ]] && echo "    - $file (mentioned in docs)"
            done
        fi
    done

    if [[ $overlaps_found -eq 0 ]]; then
        echo ""
        echo "Recommendation: Review the above files before proceeding."
        echo "If your new task will modify any of these files, consider"
        echo "completing or merging the existing worktree first."
    fi

    return $overlaps_found
}

cmd_create() {
    local task_id=""
    local check_overlaps=false
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check-overlaps)
                check_overlaps=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            -*)
                echo "Error: Unknown option: $1" >&2
                usage
                ;;
            *)
                if [[ -z "$task_id" ]]; then
                    task_id="$1"
                else
                    echo "Error: Unexpected argument: $1" >&2
                    usage
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$task_id" ]]; then
        echo "Error: task_id is required" >&2
        usage
    fi

    local worktree_path="$WORKTREE_DIR/$task_id"

    # Verify task exists and get task type
    local task_info
    task_info=$(sqlite3 "$DB_PATH" "SELECT task_type FROM tasks WHERE id = '$task_id';")
    if [[ -z "$task_info" ]]; then
        echo "Error: Task not found: $task_id" >&2
        exit 1
    fi
    local task_type="$task_info"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo "Error: Worktree already exists at $worktree_path" >&2
        exit 1
    fi

    # Check for overlaps with other worktrees if requested
    if [[ "$check_overlaps" == "true" ]]; then
        cd "$MAIN_REPO"
        if check_overlaps; then
            echo "No active overlaps detected with other worktrees."
        else
            # Overlaps were found and printed
            if [[ "$force" != "true" ]]; then
                echo ""
                echo -n "Continue anyway? [y/N] "
                read -r response
                if [[ ! "$response" =~ ^[Yy]$ ]]; then
                    echo "Aborted."
                    exit 1
                fi
            else
                echo ""
                echo "(--force specified, continuing anyway)"
            fi
        fi
    fi

    # Create worktree with new branch
    cd "$MAIN_REPO"
    git worktree add "$worktree_path" -b "$task_id"

    # Create directories based on task type
    if [[ "$task_type" == "bug" ]]; then
        # Bug tasks get bug_reports directory
        mkdir -p "$worktree_path/bug_reports"
        mkdir -p "$worktree_path/changelog.d"

        # Copy bug report template
        if [[ -f "$CLAUDE_DIR/templates/bug-report.md" ]]; then
            cp "$CLAUDE_DIR/templates/bug-report.md" "$worktree_path/bug_reports/$task_id.md"
            # Replace placeholder with actual task ID
            sed -i '' "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md" 2>/dev/null || \
            sed -i "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md"
            echo "Created bug report: bug_reports/$task_id.md"
        fi
    else
        # Feature tasks get planning_docs directory
        mkdir -p "$worktree_path/planning_docs/$task_id"
        mkdir -p "$worktree_path/changelog.d"
    fi

    # Update task record with worktree path
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = '$worktree_path', updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Created worktree at: $worktree_path"
    echo "Branch: $task_id"
    echo "Task type: $task_type"
}

cmd_remove() {
    local task_id="$1"
    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Check if caller is inside the worktree being removed
    local current_dir
    current_dir=$(pwd 2>/dev/null || echo "")
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        echo "Error: Your shell is inside $worktree_path which will be deleted." >&2
        echo "First run: cd $MAIN_REPO" >&2
        echo "Then retry this command." >&2
        exit 1
    fi

    cd "$MAIN_REPO"

    # Remove worktree
    git worktree remove "$worktree_path" --force

    # Delete branch if it exists
    if git branch --list "$task_id" | grep -q "$task_id"; then
        git branch -D "$task_id"
    fi

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Removed worktree for: $task_id"
}

cmd_list() {
    cd "$MAIN_REPO"
    echo "=== Git Worktrees ==="
    git worktree list

    echo ""
    echo "=== Task Worktrees ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT id, phase, worktree_path
FROM tasks
WHERE worktree_path IS NOT NULL AND worktree_path != '';
EOF
}

# Check for merge conflicts without actually merging
# Returns: 0 if no conflicts, 1 if conflicts exist
# Outputs: List of conflicting files to stdout if conflicts exist
check_merge_conflicts() {
    local task_id="$1"
    local has_conflicts=0
    local conflicting_files=""

    # Save current state
    local original_branch
    original_branch=$(git rev-parse --abbrev-ref HEAD)
    local original_head
    original_head=$(git rev-parse HEAD)

    # Ensure we're on main
    if [[ "$original_branch" != "main" ]]; then
        git checkout main --quiet 2>/dev/null
    fi

    # Try merge with --no-commit to detect conflicts
    if ! git merge --no-commit --no-ff "$task_id" 2>/dev/null; then
        has_conflicts=1
        # Get list of conflicting files
        conflicting_files=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")
    fi

    # Abort the test merge to restore clean state
    git merge --abort 2>/dev/null || true

    # Restore original state if we changed branches
    if [[ "$original_branch" != "main" ]]; then
        git checkout "$original_branch" --quiet 2>/dev/null || true
    fi

    # Output conflicting files if any
    if [[ -n "$conflicting_files" ]]; then
        echo "$conflicting_files"
    fi

    return $has_conflicts
}

cmd_merge() {
    local task_id="$1"
    shift || true

    # Parse optional flags
    local skip_sync=false
    local check_only=false
    local force=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-sync)
                skip_sync=true
                shift
                ;;
            --check-only)
                check_only=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Get task type and current phase before merge (needed for phase transition)
    local task_info
    task_info=$(sqlite3 "$DB_PATH" "SELECT task_type, phase FROM tasks WHERE id = '$task_id';")
    if [[ -z "$task_info" ]]; then
        echo "Error: Task not found in database: $task_id" >&2
        exit 1
    fi
    local task_type
    task_type=$(echo "$task_info" | cut -d'|' -f1)
    local current_phase
    current_phase=$(echo "$task_info" | cut -d'|' -f2)

    # Check for merge lock (system DEGRADED) - skip for check-only
    if [[ "$check_only" != "true" ]]; then
        local merge_lock
        merge_lock=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merge_lock';" 2>/dev/null || echo "0")
        if [[ "$merge_lock" -gt 0 ]]; then
            echo "Error: Merge lock is active (system DEGRADED)" >&2
            echo "E2E tests must pass before merging. Run claws-status health for details." >&2
            exit 1
        fi
    fi

    # Check if caller is inside the worktree being merged/removed - skip for check-only
    if [[ "$check_only" != "true" ]]; then
        local current_dir
        current_dir=$(pwd 2>/dev/null || echo "")
        if [[ "$current_dir" == "$worktree_path"* ]]; then
            echo "Error: Your shell is inside $worktree_path which will be deleted after merge." >&2
            echo "First run: cd $MAIN_REPO" >&2
            echo "Then retry this command." >&2
            exit 1
        fi
    fi

    cd "$MAIN_REPO"

    # Ensure we're on main and up to date
    git checkout main
    git pull origin main 2>/dev/null || true  # May fail if no remote

    # Pre-merge conflict check
    echo "Checking for merge conflicts..."
    local conflicting_files
    if ! conflicting_files=$(check_merge_conflicts "$task_id"); then
        echo ""
        echo "WARNING: Merge would result in conflicts!"
        echo ""
        echo "Conflicting files:"
        echo "$conflicting_files" | while read -r file; do
            echo "  - $file"
        done
        echo ""

        if [[ "$check_only" == "true" ]]; then
            echo "Merge check: CONFLICTS"
            echo ""
            echo "Options:"
            echo "  1. Rebase worktree on main first"
            echo "  2. Resolve conflicts in worktree before merge"
            echo "  3. Use --force to attempt merge anyway"
            exit 1
        fi

        if [[ "$force" != "true" ]]; then
            echo "Options:"
            echo "  1. Rebase worktree on main first"
            echo "  2. Resolve conflicts in worktree before merge"
            echo "  3. Use --force to attempt merge anyway"
            echo ""
            echo "Merge aborted. Use --force to proceed anyway."
            exit 1
        fi

        echo "Proceeding with merge despite conflicts (--force specified)..."
        echo ""
    else
        if [[ "$check_only" == "true" ]]; then
            echo "Merge check: OK (no conflicts detected)"
            exit 0
        fi
        echo "No conflicts detected."
    fi

    # Merge the task branch
    echo "Merging $task_id into main..."
    if ! git merge --no-ff "$task_id" -m "Merge task $task_id"; then
        echo "Error: Merge failed. Resolve conflicts and try again." >&2
        exit 1
    fi

    # Get the merge commit SHA
    local merge_commit
    merge_commit=$(git rev-parse HEAD)

    # Record merge in database
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO merge_log (task_id, merge_commit) VALUES ('$task_id', '$merge_commit');
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_e2e';
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_docs';
EOF

    echo "Merge complete: $merge_commit"

    # Sync dependencies if not skipped
    if [[ "$skip_sync" == "false" ]]; then
        echo "Syncing dependencies..."
        if [ -f "uv.lock" ]; then
            if command -v uv &> /dev/null; then
                uv sync
                echo "Dependencies synced via uv"
            else
                echo "Warning: uv.lock exists but uv not found in PATH" >&2
            fi
        elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
            echo "Dependencies synced via pip (requirements.txt)"
        elif [ -f "pyproject.toml" ]; then
            pip install -e .
            echo "Dependencies synced via pip (pyproject.toml)"
        else
            echo "No dependency file found (uv.lock, requirements.txt, pyproject.toml)"
        fi
    else
        echo "Skipping dependency sync (--skip-sync)"
    fi

    # Remove worktree
    git worktree remove "$worktree_path" --force
    git branch -D "$task_id"

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Cleaned up worktree and branch for: $task_id"

    # BUG-066 fix: Auto-transition task phase after successful merge
    # - Bug tasks: transition to DONE (merge is final step)
    # - Feature tasks: transition to VERIFY (still need verification on main)
    local new_phase
    if [[ "$task_type" == "bug" ]]; then
        new_phase="DONE"
    else
        new_phase="VERIFY"
    fi

    sqlite3 "$DB_PATH" "UPDATE tasks SET phase = '$new_phase', updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"
    echo "Task phase updated: $current_phase â†’ $new_phase"

    # Check batch job triggers
    local merges_since_e2e
    merges_since_e2e=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_e2e';")
    if [[ "$merges_since_e2e" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_e2e merges since last E2E run ***"
        echo "*** Consider running E2E tests ***"
    fi

    local merges_since_docs
    merges_since_docs=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_docs';")
    if [[ "$merges_since_docs" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_docs merges since last doc update ***"
        echo "*** Consider updating documentation ***"
    fi
}

cmd_path() {
    local task_id="$1"
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$task_id';")

    if [[ -z "$worktree_path" ]]; then
        echo "Error: No worktree path for task: $task_id" >&2
        exit 1
    fi

    echo "$worktree_path"
}

cmd_health() {
    local fix_mode=false
    local dry_run=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix)
                fix_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    cd "$MAIN_REPO"

    echo "Worktree Health Report"
    echo "======================"
    echo ""

    local has_issues=false
    local ok_count=0
    local warning_count=0
    local error_count=0

    # Get list of actual worktree directories
    if [[ ! -d "$WORKTREE_DIR" ]]; then
        echo "No worktrees directory found at $WORKTREE_DIR"
        echo ""
        echo "Summary: No worktrees to check"
        return 0
    fi

    # Track worktrees we've checked
    local checked_worktrees=()

    for worktree_path in "$WORKTREE_DIR"/*; do
        if [[ ! -d "$worktree_path" ]]; then
            continue
        fi

        local task_id
        task_id=$(basename "$worktree_path")
        checked_worktrees+=("$task_id")

        local issues=()
        local status="OK"
        local status_icon="OK"

        # Check if task exists in database
        local task_phase
        task_phase=$(sqlite3 "$DB_PATH" "SELECT phase FROM tasks WHERE id = '$task_id';" 2>/dev/null)

        if [[ -z "$task_phase" ]]; then
            issues+=("Task not found in database")
            issues+=("Orphaned worktree (recommend: claws-worktree remove $task_id)")
            status="ERROR"
            status_icon="ERROR"
            ((error_count++))
        else
            # Check if task is done but worktree exists
            if [[ "$task_phase" == "DONE" ]]; then
                issues+=("Task in DONE phase but worktree exists")
                issues+=("Should be cleaned up (recommend: claws-worktree remove $task_id)")
                if [[ "$status" != "ERROR" ]]; then
                    status="WARNING"
                    status_icon="WARNING"
                    ((warning_count++))
                fi
            fi
        fi

        # Check for uncommitted changes
        if [[ -d "$worktree_path/.git" ]] || [[ -f "$worktree_path/.git" ]]; then
            cd "$worktree_path"

            # Check for staged or unstaged changes
            local uncommitted_count=0
            uncommitted_count=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')

            if [[ "$uncommitted_count" -gt 0 ]]; then
                issues+=("Uncommitted changes: $uncommitted_count files")
                if [[ "$status" == "OK" ]]; then
                    status="WARNING"
                    status_icon="WARNING"
                    ((warning_count++))
                fi
            fi

            # Check for untracked files
            local untracked_count=0
            untracked_count=$(git status --porcelain 2>/dev/null | grep -c '^\?\?' || true)
            if [[ "$untracked_count" -gt 0 ]]; then
                issues+=("Untracked files: $untracked_count")
            fi

            # Check branch divergence from main
            local main_branch="main"
            local ahead=0
            local behind=0
            if git rev-parse --verify "$main_branch" &>/dev/null; then
                ahead=$(git rev-list --count "$main_branch..HEAD" 2>/dev/null || echo "0")
                behind=$(git rev-list --count "HEAD..$main_branch" 2>/dev/null || echo "0")
                if [[ "$behind" -gt 0 ]]; then
                    issues+=("Branch is $behind commits behind main")
                fi
                if [[ "$ahead" -gt 0 ]]; then
                    issues+=("Branch is $ahead commits ahead of main")
                fi
            fi

            # Check staleness (no commits in >7 days)
            local last_commit_time
            last_commit_time=$(git log -1 --format=%ct 2>/dev/null || echo "0")
            local now
            now=$(date +%s)
            local days_stale=$(( (now - last_commit_time) / 86400 ))
            if [[ "$days_stale" -gt 7 ]]; then
                issues+=("No commits in $days_stale days (stale)")
                if [[ "$status" == "OK" ]]; then
                    status="WARNING"
                    status_icon="WARNING"
                    ((warning_count++))
                fi
            fi

            cd "$MAIN_REPO"
        fi

        # Calculate disk usage
        local disk_usage
        disk_usage=$(du -sh "$worktree_path" 2>/dev/null | cut -f1 || echo "unknown")

        # Print report for this worktree
        echo "$task_id: $status_icon"

        if [[ -n "$task_phase" ]]; then
            echo "  - Task phase: $task_phase"
        fi

        echo "  - Disk usage: $disk_usage"

        if [[ ${#issues[@]} -eq 0 ]]; then
            echo "  - Clean working tree"
            ((ok_count++))
        else
            for issue in "${issues[@]}"; do
                echo "  - $issue"
            done
            has_issues=true
        fi
        echo ""

        # Auto-fix if requested
        if [[ "$fix_mode" == true && "$status" == "ERROR" ]]; then
            # Only auto-fix orphaned worktrees (no task record)
            if [[ -z "$task_phase" ]]; then
                if [[ "$dry_run" == true ]]; then
                    echo "  [DRY-RUN] Would remove orphaned worktree: $task_id"
                else
                    echo "  [FIX] Removing orphaned worktree: $task_id"
                    cmd_remove "$task_id" 2>/dev/null || echo "  [FIX] Failed to remove $task_id"
                fi
            fi
        fi

        if [[ "$fix_mode" == true && "$task_phase" == "DONE" ]]; then
            if [[ "$dry_run" == true ]]; then
                echo "  [DRY-RUN] Would remove worktree for DONE task: $task_id"
            else
                echo "  [FIX] Removing worktree for DONE task: $task_id"
                cmd_remove "$task_id" 2>/dev/null || echo "  [FIX] Failed to remove $task_id"
            fi
        fi
    done

    # Check for tasks with worktree_path set but no actual worktree
    local orphaned_records
    orphaned_records=$(sqlite3 "$DB_PATH" "SELECT id, worktree_path FROM tasks WHERE worktree_path IS NOT NULL AND worktree_path != '';" 2>/dev/null)

    if [[ -n "$orphaned_records" ]]; then
        while IFS='|' read -r task_id recorded_path; do
            # Skip if we already checked this worktree
            local found=false
            for checked in "${checked_worktrees[@]}"; do
                if [[ "$checked" == "$task_id" ]]; then
                    found=true
                    break
                fi
            done

            if [[ "$found" == false ]] && [[ -n "$task_id" ]]; then
                echo "$task_id: WARNING"
                echo "  - Database has worktree_path but directory missing: $recorded_path"
                echo "  - Consider updating task record"
                echo ""
                ((warning_count++))

                if [[ "$fix_mode" == true ]]; then
                    if [[ "$dry_run" == true ]]; then
                        echo "  [DRY-RUN] Would clear orphaned worktree_path in database for: $task_id"
                    else
                        echo "  [FIX] Clearing orphaned worktree_path in database for: $task_id"
                        sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL WHERE id = '$task_id';"
                    fi
                fi
            fi
        done <<< "$orphaned_records"
    fi

    # Print summary
    echo "======================"
    echo "Summary"
    echo "  OK:       $ok_count"
    echo "  Warnings: $warning_count"
    echo "  Errors:   $error_count"

    if [[ "$has_issues" == true ]]; then
        echo ""
        echo "Run 'claws-worktree health --fix' to auto-remediate (removes orphaned/DONE worktrees)"
        echo "Run 'claws-worktree health --fix --dry-run' to preview changes"
        return 1
    fi

    return 0
}

# Main
if [[ $# -lt 1 ]]; then
    usage
fi

command="$1"
shift

case "$command" in
    create)
        [[ $# -lt 1 ]] && usage
        cmd_create "$@"
        ;;
    remove)
        [[ $# -lt 1 ]] && usage
        cmd_remove "$@"
        ;;
    list)
        cmd_list
        ;;
    merge)
        [[ $# -lt 1 ]] && usage
        cmd_merge "$@"
        ;;
    path)
        [[ $# -lt 1 ]] && usage
        cmd_path "$@"
        ;;
    health)
        cmd_health "$@"
        ;;
    *)
        echo "Unknown command: $command" >&2
        usage
        ;;
esac
