#!/usr/bin/env bash
#
# claws-worktree: Git worktree lifecycle management
#
# Usage:
#   claws-worktree create <task_id>       Create worktree for task
#   claws-worktree remove <task_id>       Remove worktree (no merge)
#   claws-worktree list                   List all worktrees
#   claws-worktree merge <task_id> [--skip-sync]  Merge to main and cleanup
#   claws-worktree path <task_id>         Print worktree path

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/claws-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run claws-init first." >&2
    exit 1
fi

usage() {
    echo "Usage:"
    echo "  claws-worktree create <task_id>   Create worktree for task"
    echo "  claws-worktree remove <task_id>   Remove worktree (no merge)"
    echo "  claws-worktree list               List all worktrees"
    echo "  claws-worktree merge <task_id> [--skip-sync]  Merge to main and cleanup"
    echo "  claws-worktree path <task_id>     Print worktree path"
    exit 1
}

cmd_create() {
    local task_id="$1"
    local worktree_path="$WORKTREE_DIR/$task_id"

    # Verify task exists and get task type
    local task_info
    task_info=$(sqlite3 "$DB_PATH" "SELECT task_type FROM tasks WHERE id = '$task_id';")
    if [[ -z "$task_info" ]]; then
        echo "Error: Task not found: $task_id" >&2
        exit 1
    fi
    local task_type="$task_info"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo "Error: Worktree already exists at $worktree_path" >&2
        exit 1
    fi

    # Create worktree with new branch
    cd "$MAIN_REPO"
    git worktree add "$worktree_path" -b "$task_id"

    # Create directories based on task type
    if [[ "$task_type" == "bug" ]]; then
        # Bug tasks get bug_reports directory
        mkdir -p "$worktree_path/bug_reports"
        mkdir -p "$worktree_path/changelog.d"

        # Copy bug report template
        if [[ -f "$CLAUDE_DIR/templates/bug-report.md" ]]; then
            cp "$CLAUDE_DIR/templates/bug-report.md" "$worktree_path/bug_reports/$task_id.md"
            # Replace placeholder with actual task ID
            sed -i '' "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md" 2>/dev/null || \
            sed -i "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md"
            echo "Created bug report: bug_reports/$task_id.md"
        fi
    else
        # Feature tasks get planning_docs directory
        mkdir -p "$worktree_path/planning_docs/$task_id"
        mkdir -p "$worktree_path/changelog.d"
    fi

    # Update task record with worktree path
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = '$worktree_path', updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Created worktree at: $worktree_path"
    echo "Branch: $task_id"
    echo "Task type: $task_type"
}

cmd_remove() {
    local task_id="$1"
    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Check if caller is inside the worktree being removed
    local current_dir
    current_dir=$(pwd 2>/dev/null || echo "")
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        echo "Error: Your shell is inside $worktree_path which will be deleted." >&2
        echo "First run: cd $MAIN_REPO" >&2
        echo "Then retry this command." >&2
        exit 1
    fi

    cd "$MAIN_REPO"

    # Remove worktree
    git worktree remove "$worktree_path" --force

    # Delete branch if it exists
    if git branch --list "$task_id" | grep -q "$task_id"; then
        git branch -D "$task_id"
    fi

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Removed worktree for: $task_id"
}

cmd_list() {
    cd "$MAIN_REPO"
    echo "=== Git Worktrees ==="
    git worktree list

    echo ""
    echo "=== Task Worktrees ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT id, phase, worktree_path
FROM tasks
WHERE worktree_path IS NOT NULL AND worktree_path != '';
EOF
}

cmd_merge() {
    local task_id="$1"
    shift || true
    local skip_sync=false

    # Parse optional flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-sync)
                skip_sync=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Check for merge lock (system DEGRADED)
    local merge_lock
    merge_lock=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merge_lock';" 2>/dev/null || echo "0")
    if [[ "$merge_lock" -gt 0 ]]; then
        echo "Error: Merge lock is active (system DEGRADED)" >&2
        echo "E2E tests must pass before merging. Run claws-status health for details." >&2
        exit 1
    fi

    # Check if caller is inside the worktree being merged/removed
    local current_dir
    current_dir=$(pwd 2>/dev/null || echo "")
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        echo "Error: Your shell is inside $worktree_path which will be deleted after merge." >&2
        echo "First run: cd $MAIN_REPO" >&2
        echo "Then retry this command." >&2
        exit 1
    fi

    cd "$MAIN_REPO"

    # Ensure we're on main and up to date
    git checkout main
    git pull origin main 2>/dev/null || true  # May fail if no remote

    # Merge the task branch
    echo "Merging $task_id into main..."
    if ! git merge --no-ff "$task_id" -m "Merge task $task_id"; then
        echo "Error: Merge failed. Resolve conflicts and try again." >&2
        exit 1
    fi

    # Get the merge commit SHA
    local merge_commit
    merge_commit=$(git rev-parse HEAD)

    # Record merge in database
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO merge_log (task_id, merge_commit) VALUES ('$task_id', '$merge_commit');
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_e2e';
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_docs';
EOF

    echo "Merge complete: $merge_commit"

    # Sync dependencies if not skipped
    if [[ "$skip_sync" == "false" ]]; then
        echo "Syncing dependencies..."
        if [ -f "uv.lock" ]; then
            if command -v uv &> /dev/null; then
                uv sync
                echo "Dependencies synced via uv"
            else
                echo "Warning: uv.lock exists but uv not found in PATH" >&2
            fi
        elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
            echo "Dependencies synced via pip (requirements.txt)"
        elif [ -f "pyproject.toml" ]; then
            pip install -e .
            echo "Dependencies synced via pip (pyproject.toml)"
        else
            echo "No dependency file found (uv.lock, requirements.txt, pyproject.toml)"
        fi
    else
        echo "Skipping dependency sync (--skip-sync)"
    fi

    # Remove worktree
    git worktree remove "$worktree_path" --force
    git branch -D "$task_id"

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Cleaned up worktree and branch for: $task_id"

    # Check batch job triggers
    local merges_since_e2e
    merges_since_e2e=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_e2e';")
    if [[ "$merges_since_e2e" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_e2e merges since last E2E run ***"
        echo "*** Consider running E2E tests ***"
    fi

    local merges_since_docs
    merges_since_docs=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_docs';")
    if [[ "$merges_since_docs" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_docs merges since last doc update ***"
        echo "*** Consider updating documentation ***"
    fi
}

cmd_path() {
    local task_id="$1"
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$task_id';")

    if [[ -z "$worktree_path" ]]; then
        echo "Error: No worktree path for task: $task_id" >&2
        exit 1
    fi

    echo "$worktree_path"
}

# Main
if [[ $# -lt 1 ]]; then
    usage
fi

command="$1"
shift

case "$command" in
    create)
        [[ $# -lt 1 ]] && usage
        cmd_create "$@"
        ;;
    remove)
        [[ $# -lt 1 ]] && usage
        cmd_remove "$@"
        ;;
    list)
        cmd_list
        ;;
    merge)
        [[ $# -lt 1 ]] && usage
        cmd_merge "$@"
        ;;
    path)
        [[ $# -lt 1 ]] && usage
        cmd_path "$@"
        ;;
    *)
        echo "Unknown command: $command" >&2
        usage
        ;;
esac
