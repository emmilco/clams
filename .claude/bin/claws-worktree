#!/usr/bin/env bash
#
# claws-worktree: Git worktree lifecycle management
#
# Usage:
#   claws-worktree create <task_id>                   Create worktree for task
#   claws-worktree remove <task_id>                   Remove worktree (no merge)
#   claws-worktree list                               List all worktrees
#   claws-worktree merge <task_id> [--check-only] [--force]
#                                                     Merge to main and cleanup
#     --check-only: Only check for conflicts, don't merge
#     --force: Attempt merge even if conflicts detected
#   claws-worktree path <task_id>                     Print worktree path

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/claws-common.sh"

if [[ ! -f "$DB_PATH" ]]; then
    echo "Error: Database not found at $DB_PATH. Run claws-init first." >&2
    exit 1
fi

usage() {
    echo "Usage:"
    echo "  claws-worktree create <task_id>   Create worktree for task"
    echo "  claws-worktree remove <task_id>   Remove worktree (no merge)"
    echo "  claws-worktree list               List all worktrees"
    echo "  claws-worktree merge <task_id> [--check-only] [--force]"
    echo "                                    Merge to main and cleanup"
    echo "    --check-only: Only check for conflicts, don't merge"
    echo "    --force: Attempt merge even if conflicts detected"
    echo "  claws-worktree path <task_id>     Print worktree path"
    exit 1
}

cmd_create() {
    local task_id="$1"
    local worktree_path="$WORKTREE_DIR/$task_id"

    # Verify task exists and get task type
    local task_info
    task_info=$(sqlite3 "$DB_PATH" "SELECT task_type FROM tasks WHERE id = '$task_id';")
    if [[ -z "$task_info" ]]; then
        echo "Error: Task not found: $task_id" >&2
        exit 1
    fi
    local task_type="$task_info"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo "Error: Worktree already exists at $worktree_path" >&2
        exit 1
    fi

    # Create worktree with new branch
    cd "$MAIN_REPO"
    git worktree add "$worktree_path" -b "$task_id"

    # Create directories based on task type
    if [[ "$task_type" == "bug" ]]; then
        # Bug tasks get bug_reports directory
        mkdir -p "$worktree_path/bug_reports"
        mkdir -p "$worktree_path/changelog.d"

        # Copy bug report template
        if [[ -f "$CLAUDE_DIR/templates/bug-report.md" ]]; then
            cp "$CLAUDE_DIR/templates/bug-report.md" "$worktree_path/bug_reports/$task_id.md"
            # Replace placeholder with actual task ID
            sed -i '' "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md" 2>/dev/null || \
            sed -i "s/BUG-XXX/$task_id/g" "$worktree_path/bug_reports/$task_id.md"
            echo "Created bug report: bug_reports/$task_id.md"
        fi
    else
        # Feature tasks get planning_docs directory
        mkdir -p "$worktree_path/planning_docs/$task_id"
        mkdir -p "$worktree_path/changelog.d"
    fi

    # Update task record with worktree path
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = '$worktree_path', updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Created worktree at: $worktree_path"
    echo "Branch: $task_id"
    echo "Task type: $task_type"
}

cmd_remove() {
    local task_id="$1"
    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Check if caller is inside the worktree being removed
    local current_dir
    current_dir=$(pwd 2>/dev/null || echo "")
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        echo "Error: Your shell is inside $worktree_path which will be deleted." >&2
        echo "First run: cd $MAIN_REPO" >&2
        echo "Then retry this command." >&2
        exit 1
    fi

    cd "$MAIN_REPO"

    # Remove worktree
    git worktree remove "$worktree_path" --force

    # Delete branch if it exists
    if git branch --list "$task_id" | grep -q "$task_id"; then
        git branch -D "$task_id"
    fi

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Removed worktree for: $task_id"
}

cmd_list() {
    cd "$MAIN_REPO"
    echo "=== Git Worktrees ==="
    git worktree list

    echo ""
    echo "=== Task Worktrees ==="
    sqlite3 -header -column "$DB_PATH" <<EOF
SELECT id, phase, worktree_path
FROM tasks
WHERE worktree_path IS NOT NULL AND worktree_path != '';
EOF
}

# Check for merge conflicts without actually merging
# Returns: 0 if no conflicts, 1 if conflicts exist
# Outputs: List of conflicting files to stdout if conflicts exist
check_merge_conflicts() {
    local task_id="$1"
    local has_conflicts=0
    local conflicting_files=""

    # Save current state
    local original_branch
    original_branch=$(git rev-parse --abbrev-ref HEAD)
    local original_head
    original_head=$(git rev-parse HEAD)

    # Ensure we're on main
    if [[ "$original_branch" != "main" ]]; then
        git checkout main --quiet 2>/dev/null
    fi

    # Try merge with --no-commit to detect conflicts
    if ! git merge --no-commit --no-ff "$task_id" 2>/dev/null; then
        has_conflicts=1
        # Get list of conflicting files
        conflicting_files=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")
    fi

    # Abort the test merge to restore clean state
    git merge --abort 2>/dev/null || true

    # Restore original state if we changed branches
    if [[ "$original_branch" != "main" ]]; then
        git checkout "$original_branch" --quiet 2>/dev/null || true
    fi

    # Output conflicting files if any
    if [[ -n "$conflicting_files" ]]; then
        echo "$conflicting_files"
    fi

    return $has_conflicts
}

cmd_merge() {
    local task_id="$1"
    shift  # Remove task_id from arguments

    # Parse options
    local check_only=false
    local force=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check-only)
                check_only=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                ;;
        esac
    done

    local worktree_path="$WORKTREE_DIR/$task_id"

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree not found at $worktree_path" >&2
        exit 1
    fi

    # Check for merge lock (system DEGRADED) - skip for check-only
    if [[ "$check_only" != "true" ]]; then
        local merge_lock
        merge_lock=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merge_lock';" 2>/dev/null || echo "0")
        if [[ "$merge_lock" -gt 0 ]]; then
            echo "Error: Merge lock is active (system DEGRADED)" >&2
            echo "E2E tests must pass before merging. Run claws-status health for details." >&2
            exit 1
        fi
    fi

    # Check if caller is inside the worktree being merged/removed - skip for check-only
    if [[ "$check_only" != "true" ]]; then
        local current_dir
        current_dir=$(pwd 2>/dev/null || echo "")
        if [[ "$current_dir" == "$worktree_path"* ]]; then
            echo "Error: Your shell is inside $worktree_path which will be deleted after merge." >&2
            echo "First run: cd $MAIN_REPO" >&2
            echo "Then retry this command." >&2
            exit 1
        fi
    fi

    cd "$MAIN_REPO"

    # Ensure we're on main and up to date
    git checkout main
    git pull origin main 2>/dev/null || true  # May fail if no remote

    # Pre-merge conflict check
    echo "Checking for merge conflicts..."
    local conflicting_files
    if ! conflicting_files=$(check_merge_conflicts "$task_id"); then
        echo ""
        echo "WARNING: Merge would result in conflicts!"
        echo ""
        echo "Conflicting files:"
        echo "$conflicting_files" | while read -r file; do
            echo "  - $file"
        done
        echo ""

        if [[ "$check_only" == "true" ]]; then
            echo "Merge check: CONFLICTS"
            echo ""
            echo "Options:"
            echo "  1. Rebase worktree on main first"
            echo "  2. Resolve conflicts in worktree before merge"
            echo "  3. Use --force to attempt merge anyway"
            exit 1
        fi

        if [[ "$force" != "true" ]]; then
            echo "Options:"
            echo "  1. Rebase worktree on main first"
            echo "  2. Resolve conflicts in worktree before merge"
            echo "  3. Use --force to attempt merge anyway"
            echo ""
            echo "Merge aborted. Use --force to proceed anyway."
            exit 1
        fi

        echo "Proceeding with merge despite conflicts (--force specified)..."
        echo ""
    else
        if [[ "$check_only" == "true" ]]; then
            echo "Merge check: OK (no conflicts detected)"
            exit 0
        fi
        echo "No conflicts detected."
    fi

    # Merge the task branch
    echo "Merging $task_id into main..."
    if ! git merge --no-ff "$task_id" -m "Merge task $task_id"; then
        echo "Error: Merge failed. Resolve conflicts and try again." >&2
        exit 1
    fi

    # Get the merge commit SHA
    local merge_commit
    merge_commit=$(git rev-parse HEAD)

    # Record merge in database
    sqlite3 "$DB_PATH" <<EOF
INSERT INTO merge_log (task_id, merge_commit) VALUES ('$task_id', '$merge_commit');
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_e2e';
UPDATE system_counters SET value = value + 1 WHERE name = 'merges_since_docs';
EOF

    echo "Merge complete: $merge_commit"

    # Remove worktree
    git worktree remove "$worktree_path" --force
    git branch -D "$task_id"

    # Clear worktree path in task record
    sqlite3 "$DB_PATH" "UPDATE tasks SET worktree_path = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = '$task_id';"

    echo "Cleaned up worktree and branch for: $task_id"

    # Check batch job triggers
    local merges_since_e2e
    merges_since_e2e=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_e2e';")
    if [[ "$merges_since_e2e" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_e2e merges since last E2E run ***"
        echo "*** Consider running E2E tests ***"
    fi

    local merges_since_docs
    merges_since_docs=$(sqlite3 "$DB_PATH" "SELECT value FROM system_counters WHERE name = 'merges_since_docs';")
    if [[ "$merges_since_docs" -ge 12 ]]; then
        echo ""
        echo "*** BATCH JOB TRIGGER: $merges_since_docs merges since last doc update ***"
        echo "*** Consider updating documentation ***"
    fi
}

cmd_path() {
    local task_id="$1"
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM tasks WHERE id = '$task_id';")

    if [[ -z "$worktree_path" ]]; then
        echo "Error: No worktree path for task: $task_id" >&2
        exit 1
    fi

    echo "$worktree_path"
}

# Main
if [[ $# -lt 1 ]]; then
    usage
fi

command="$1"
shift

case "$command" in
    create)
        [[ $# -lt 1 ]] && usage
        cmd_create "$@"
        ;;
    remove)
        [[ $# -lt 1 ]] && usage
        cmd_remove "$@"
        ;;
    list)
        cmd_list
        ;;
    merge)
        [[ $# -lt 1 ]] && usage
        cmd_merge "$@"
        ;;
    path)
        [[ $# -lt 1 ]] && usage
        cmd_path "$@"
        ;;
    *)
        echo "Unknown command: $command" >&2
        usage
        ;;
esac
